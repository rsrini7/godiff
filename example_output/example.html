<!doctype html><html><head>
<meta http-equiv="content-type" content="text/html;charset=utf-8"><title>Compare vim73/src/regexp.c vs vim74/src/regexp.c</title>
<style type="text/css">
.tab {border-color:#808080; border-style:solid; border-width:1px 1px 1px 1px; border-collapse:collapse;}
.tth {border-color:#808080; border-style:solid; border-width:1px 1px 1px 1px; border-collapse:collapse; padding:4px; vertical-align:top; text-align:left; background-color:#E0E0E0;}
.ttd {border-color:#808080; border-style:solid; border-width:1px 1px 1px 1px; border-collapse:collapse; padding:4px; vertical-align:top; text-align:left;}
.hdr {color:black; font-size:85%;}
.inf {color:#C08000; font-size:85%;}
.err {color:red; font-size:85%; font-weight:bold; margin:0; display:block;}
.msg {color:#508050; font-size:85%; font-weight:bold; margin:0; display:block;}
.lin {color:#C08000; font-size:75%; font-weight:bold; font-style:italic; margin:0; display:block;}
.lno {color:#C08000; background-color:white; font-style:italic; margin:0;}
.nop {color:black; font-size:75%; font-family:monospace; white-space:pre; margin:0; display:block;}
.upd {color:black; font-size:75%; font-family:monospace; white-space:pre; margin:0; background-color:#CFCFFF; display:block;}
.chg {color:#C00080;}
.add {color:black; font-size:75%; font-family:monospace; white-space:pre; margin:0; background-color:#CFFFCF; display:block;}
.del {color:black; font-size:75%; font-family:monospace; white-space:pre; margin:0; background-color:#FFCFCF; display:block;}
</style></head><body>
<p>Compare <strong>vim73/src/regexp.c</strong> vs <strong>vim74/src/regexp.c</strong></p>
<table class="tab"><tr><td class="tth"><span class="hdr">vim73/src/regexp.c</span><br><span class="inf">176566 Tue, 13 Jul 2010 06:41:48 EST</span></td><td class="tth"><span class="hdr">vim74/src/regexp.c</span><br><span class="inf">198032 Fri, 02 Aug 2013 02:31:30 EST</span></td></tr><tr><td class="ttd"><span class="lin">Line 38 to 46</span><span class="nop"><span class="lno">38   </span> * Named character class support added by Walter Briscoe (1998 Jul 01)
<span class="lno">39   </span> */
<span class="lno">40   </span>
</span><span class="nop"><span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
</span><span class="nop"><span class="lno">41   </span>#include &#34;vim.h&#34;
<span class="lno">42   </span>
</span><span class="upd"><span class="lno">43   </span>#<span class="chg">un</span>def DEBUG
</span><span class="nop"><span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
</span><span class="nop"><span class="lno">44   </span>
<span class="lno">45   </span>/*
<span class="lno">46   </span> * The &#34;internal use only&#34; fields in regexp.h are present to pass info from
</span></td><td class="ttd"><span class="lin">Line 38 to 59</span><span class="nop"><span class="lno">38   </span> * Named character class support added by Walter Briscoe (1998 Jul 01)
<span class="lno">39   </span> */
<span class="lno">40   </span>
</span><span class="add"><span class="lno">41   </span>/* Uncomment the first if you do not want to see debugging logs or files
<span class="lno">42   </span> * related to regular expressions, even when compiling with -DDEBUG.
<span class="lno">43   </span> * Uncomment the second to get the regexp debugging. */
<span class="lno">44   </span>/* #undef DEBUG */
<span class="lno">45   </span>/* #define DEBUG */
<span class="lno">46   </span>
</span><span class="nop"><span class="lno">47   </span>#include &#34;vim.h&#34;
<span class="lno">48   </span>
</span><span class="upd"><span class="lno">49   </span>#<span class="chg">if</span>def DEBUG
</span><span class="add"><span class="lno">50   </span>/* show/save debugging data when BT engine is used */
<span class="lno">51   </span># define BT_REGEXP_DUMP
<span class="lno">52   </span>/* save the debugging data to a file instead of displaying it */
<span class="lno">53   </span># define BT_REGEXP_LOG
<span class="lno">54   </span># define BT_REGEXP_DEBUG_LOG
<span class="lno">55   </span># define BT_REGEXP_DEBUG_LOG_NAME	&#34;bt_regexp_debug.log&#34;
<span class="lno">56   </span>#endif
</span><span class="nop"><span class="lno">57   </span>
<span class="lno">58   </span>/*
<span class="lno">59   </span> * The &#34;internal use only&#34; fields in regexp.h are present to pass info from
</span></td></tr>
<tr><td class="ttd"><span class="lin">Line 326 to 334</span><span class="nop"><span class="lno">326  </span>/* Used for an error (down from) vim_regcomp(): give the error message, set
<span class="lno">327  </span> * rc_did_emsg and return NULL */
<span class="lno">328  </span>#define EMSG_RET_NULL(m) return (EMSG(m), rc_did_emsg = TRUE, (void *)NULL)
</span><span class="del"><span class="lno">329  </span>#define EMSG_M_RET_NULL(m, c) return (EMSG2((m), (c) ? &#34;&#34; : &#34;\\&#34;), rc_did_emsg = TRUE, (void *)NULL)
</span><span class="nop"><span class="lno">330  </span>#define EMSG_RET_FAIL(m) return (EMSG(m), rc_did_emsg = TRUE, FAIL)
</span><span class="upd"><span class="lno">331  </span>#define EMSG_<span class="chg">ONE_</span>RET_NULL EMSG<span class="chg">_M_RET_NULL</span>(<span class="chg">_</span>(<span class="chg">&#34;E369:</span> <span class="chg">invalid</span> <span class="chg">item</span> <span class="chg">in</span> <span class="chg">%s%%[]</span>&#34;), re<span class="chg">g_</span>m<span class="chg">a</span>g<span class="chg">ic</span> =<span class="chg">=</span> <span class="chg">MAGIC_A</span>LL)
</span><span class="nop"><span class="lno"> </span>
<span class="lno"> </span>
</span><span class="nop"><span class="lno">332  </span>
<span class="lno">333  </span>#define MAX_LIMIT	(32767L &lt;&lt; 16L)
<span class="lno">334  </span>
</span></td><td class="ttd"><span class="lin">Line 339 to 348</span><span class="nop"><span class="lno">339  </span>/* Used for an error (down from) vim_regcomp(): give the error message, set
<span class="lno">340  </span> * rc_did_emsg and return NULL */
<span class="lno">341  </span>#define EMSG_RET_NULL(m) return (EMSG(m), rc_did_emsg = TRUE, (void *)NULL)
</span><span class="nop"><span class="lno"> </span>
</span><span class="nop"><span class="lno">342  </span>#define EMSG_RET_FAIL(m) return (EMSG(m), rc_did_emsg = TRUE, FAIL)
</span><span class="upd"><span class="lno">343  </span>#define EMSG<span class="chg">2</span>_RET_NULL<span class="chg">(m,</span> <span class="chg">c) return (</span>EMSG<span class="chg">2(</span>(<span class="chg">m), </span>(<span class="chg">c)</span> <span class="chg">?</span> <span class="chg">&#34;&#34;</span> <span class="chg">:</span> <span class="chg">&#34;\\</span>&#34;), r<span class="chg">c_did_</span>em<span class="chg">s</span>g = <span class="chg">TRUE, (void *)NU</span>LL)
</span><span class="add"><span class="lno">344  </span>#define EMSG2_RET_FAIL(m, c) return (EMSG2((m), (c) ? &#34;&#34; : &#34;\\&#34;), rc_did_emsg = TRUE, FAIL)
<span class="lno">345  </span>#define EMSG_ONE_RET_NULL EMSG2_RET_NULL(_(&#34;E369: invalid item in %s%%[]&#34;), reg_magic == MAGIC_ALL)
</span><span class="nop"><span class="lno">346  </span>
<span class="lno">347  </span>#define MAX_LIMIT	(32767L &lt;&lt; 16L)
<span class="lno">348  </span>
</span></td></tr>
<tr><td class="ttd"><span class="lin">Line 336 to 346</span><span class="nop"><span class="lno">336  </span>static int cstrncmp __ARGS((char_u *s1, char_u *s2, int *n));
<span class="lno">337  </span>static char_u *cstrchr __ARGS((char_u *, int));
<span class="lno">338  </span>
</span><span class="nop"><span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
</span><span class="nop"><span class="lno">339  </span>#ifdef DEBUG
</span><span class="del"><span class="lno">340  </span>static void	regdump __ARGS((char_u *, regprog_T *));
</span><span class="nop"><span class="lno">341  </span>static char_u	*regprop __ARGS((char_u *));
<span class="lno">342  </span>#endif
<span class="lno">343  </span>
</span><span class="nop"><span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
</span><span class="nop"><span class="lno">344  </span>#define NOT_MULTI	0
<span class="lno">345  </span>#define MULTI_ONE	1
<span class="lno">346  </span>#define MULTI_MULT	2
</span></td><td class="ttd"><span class="lin">Line 350 to 372</span><span class="nop"><span class="lno">350  </span>static int cstrncmp __ARGS((char_u *s1, char_u *s2, int *n));
<span class="lno">351  </span>static char_u *cstrchr __ARGS((char_u *, int));
<span class="lno">352  </span>
</span><span class="add"><span class="lno">353  </span>#ifdef BT_REGEXP_DUMP
<span class="lno">354  </span>static void	regdump __ARGS((char_u *, bt_regprog_T *));
<span class="lno">355  </span>#endif
</span><span class="nop"><span class="lno">356  </span>#ifdef DEBUG
</span><span class="nop"><span class="lno"> </span>
</span><span class="nop"><span class="lno">357  </span>static char_u	*regprop __ARGS((char_u *));
<span class="lno">358  </span>#endif
<span class="lno">359  </span>
</span><span class="add"><span class="lno">360  </span>static char_u e_missingbracket[] = N_(&#34;E769: Missing ] after %s[&#34;);
<span class="lno">361  </span>static char_u e_unmatchedpp[] = N_(&#34;E53: Unmatched %s%%(&#34;);
<span class="lno">362  </span>static char_u e_unmatchedp[] = N_(&#34;E54: Unmatched %s(&#34;);
<span class="lno">363  </span>static char_u e_unmatchedpar[] = N_(&#34;E55: Unmatched %s)&#34;);
<span class="lno">364  </span>#ifdef FEAT_SYN_HL
<span class="lno">365  </span>static char_u e_z_not_allowed[] = N_(&#34;E66: \\z( not allowed here&#34;);
<span class="lno">366  </span>static char_u e_z1_not_allowed[] = N_(&#34;E67: \\z1 et al. not allowed here&#34;);
<span class="lno">367  </span>#endif
<span class="lno">368  </span>static char_u e_missing_sb[] = N_(&#34;E69: Missing ] after %s%%[&#34;);
<span class="lno">369  </span>static char_u e_empty_sb[]  = N_(&#34;E70: Empty %s%%[]&#34;);
</span><span class="nop"><span class="lno">370  </span>#define NOT_MULTI	0
<span class="lno">371  </span>#define MULTI_ONE	1
<span class="lno">372  </span>#define MULTI_MULT	2
</span></td></tr>
<tr><td class="ttd"><span class="lin">Line 630 to 636</span><span class="nop"><span class="lno">630  </span>};
<span class="lno">631  </span>#endif
<span class="lno">632  </span>
</span><span class="upd"><span class="lno">633  </span>static int	curchr;
</span><span class="nop"><span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
</span><span class="nop"><span class="lno">634  </span>
<span class="lno">635  </span>/* arguments for reg() */
<span class="lno">636  </span>#define REG_NOPAREN	0	/* toplevel reg() */
</span></td><td class="ttd"><span class="lin">Line 656 to 668</span><span class="nop"><span class="lno">656  </span>};
<span class="lno">657  </span>#endif
<span class="lno">658  </span>
</span><span class="upd"><span class="lno">659  </span>static int	curchr;<span class="chg">		/* currently parsed character */</span>
</span><span class="add"><span class="lno">660  </span>/* Previous character.  Note: prevchr is sometimes -1 when we are not at the
<span class="lno">661  </span> * start, eg in /[ ^I]^ the pattern was never found even if it existed,
<span class="lno">662  </span> * because ^ was taken to be magic -- webb */
<span class="lno">663  </span>static int	prevchr;
<span class="lno">664  </span>static int	prevprevchr;	/* previous-previous character */
<span class="lno">665  </span>static int	nextchr;	/* used for ungetchr() */
</span><span class="nop"><span class="lno">666  </span>
<span class="lno">667  </span>/* arguments for reg() */
<span class="lno">668  </span>#define REG_NOPAREN	0	/* toplevel reg() */
</span></td></tr>
<tr><td class="ttd"><span class="lin">Line 638 to 647</span><span class="nop"><span class="lno">638  </span>#define REG_ZPAREN	2	/* \z(\) */
<span class="lno">639  </span>#define REG_NPAREN	3	/* \%(\) */
<span class="lno">640  </span>
</span><span class="nop"><span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
</span><span class="nop"><span class="lno">641  </span>/*
<span class="lno">642  </span> * Forward declarations for vim_regcomp()&#39;s friends.
<span class="lno">643  </span> */
</span><span class="nop"><span class="lno">644  </span>static void	initchr __ARGS((char_u *));
</span><span class="nop"><span class="lno"> </span>
<span class="lno"> </span>
</span><span class="nop"><span class="lno">645  </span>static int	getchr __ARGS((void));
<span class="lno">646  </span>static void	skipchr_keepstart __ARGS((void));
<span class="lno">647  </span>static int	peekchr __ARGS((void));
</span></td><td class="ttd"><span class="lin">Line 670 to 694</span><span class="nop"><span class="lno">670  </span>#define REG_ZPAREN	2	/* \z(\) */
<span class="lno">671  </span>#define REG_NPAREN	3	/* \%(\) */
<span class="lno">672  </span>
</span><span class="add"><span class="lno">673  </span>typedef struct
<span class="lno">674  </span>{
<span class="lno">675  </span>     char_u	*regparse;
<span class="lno">676  </span>     int	prevchr_len;
<span class="lno">677  </span>     int	curchr;
<span class="lno">678  </span>     int	prevchr;
<span class="lno">679  </span>     int	prevprevchr;
<span class="lno">680  </span>     int	nextchr;
<span class="lno">681  </span>     int	at_start;
<span class="lno">682  </span>     int	prev_at_start;
<span class="lno">683  </span>     int	regnpar;
<span class="lno">684  </span>} parse_state_T;
<span class="lno">685  </span>
</span><span class="nop"><span class="lno">686  </span>/*
<span class="lno">687  </span> * Forward declarations for vim_regcomp()&#39;s friends.
<span class="lno">688  </span> */
</span><span class="nop"><span class="lno">689  </span>static void	initchr __ARGS((char_u *));
</span><span class="add"><span class="lno">690  </span>static void	save_parse_state __ARGS((parse_state_T *ps));
<span class="lno">691  </span>static void	restore_parse_state __ARGS((parse_state_T *ps));
</span><span class="nop"><span class="lno">692  </span>static int	getchr __ARGS((void));
<span class="lno">693  </span>static void	skipchr_keepstart __ARGS((void));
<span class="lno">694  </span>static int	peekchr __ARGS((void));
</span></td></tr>
<tr><td class="ttd"><span class="lin">Line 666 to 680</span><span class="nop"><span class="lno">666  </span>static void	regc __ARGS((int b));
<span class="lno">667  </span>#ifdef FEAT_MBYTE
<span class="lno">668  </span>static void	regmbc __ARGS((int c));
</span><span class="nop"><span class="lno"> </span>
<span class="lno"> </span>
</span><span class="nop"><span class="lno">669  </span>#else
<span class="lno">670  </span># define regmbc(c) regc(c)
</span><span class="nop"><span class="lno"> </span>
<span class="lno"> </span>
</span><span class="nop"><span class="lno">671  </span>#endif
<span class="lno">672  </span>static void	reginsert __ARGS((int, char_u *));
</span><span class="nop"><span class="lno"> </span>
</span><span class="nop"><span class="lno">673  </span>static void	reginsert_limits __ARGS((int, long, long, char_u *));
<span class="lno">674  </span>static char_u	*re_put_long __ARGS((char_u *pr, long_u val));
<span class="lno">675  </span>static int	read_limits __ARGS((long *, long *));
</span><span class="nop"><span class="lno">676  </span>static void	regtail __ARGS((char_u *, char_u *));
<span class="lno">677  </span>static void	regoptail __ARGS((char_u *, char_u *));
</span><span class="nop"><span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
</span><span class="nop"><span class="lno">678  </span>
<span class="lno">679  </span>/*
<span class="lno">680  </span> * Return TRUE if compiled regular expression &#34;prog&#34; can match a line break.
</span></td><td class="ttd"><span class="lin">Line 713 to 735</span><span class="nop"><span class="lno">713  </span>static void	regc __ARGS((int b));
<span class="lno">714  </span>#ifdef FEAT_MBYTE
<span class="lno">715  </span>static void	regmbc __ARGS((int c));
</span><span class="add"><span class="lno">716  </span># define REGMBC(x) regmbc(x);
<span class="lno">717  </span># define CASEMBC(x) case x:
</span><span class="nop"><span class="lno">718  </span>#else
<span class="lno">719  </span># define regmbc(c) regc(c)
</span><span class="add"><span class="lno">720  </span># define REGMBC(x)
<span class="lno">721  </span># define CASEMBC(x)
</span><span class="nop"><span class="lno">722  </span>#endif
<span class="lno">723  </span>static void	reginsert __ARGS((int, char_u *));
</span><span class="add"><span class="lno">724  </span>static void	reginsert_nr __ARGS((int op, long val, char_u *opnd));
</span><span class="nop"><span class="lno">725  </span>static void	reginsert_limits __ARGS((int, long, long, char_u *));
<span class="lno">726  </span>static char_u	*re_put_long __ARGS((char_u *pr, long_u val));
<span class="lno">727  </span>static int	read_limits __ARGS((long *, long *));
</span><span class="nop"><span class="lno">728  </span>static void	regtail __ARGS((char_u *, char_u *));
<span class="lno">729  </span>static void	regoptail __ARGS((char_u *, char_u *));
</span><span class="add"><span class="lno">730  </span>
<span class="lno">731  </span>static regengine_T bt_regengine;
<span class="lno">732  </span>static regengine_T nfa_regengine;
</span><span class="nop"><span class="lno">733  </span>
<span class="lno">734  </span>/*
<span class="lno">735  </span> * Return TRUE if compiled regular expression &#34;prog&#34; can match a line break.
</span></td></tr>
<tr><td class="ttd"><span class="lin">Line 758 to 763</span><span class="nop"><span class="lno">758  </span>/*
<span class="lno">759  </span> * Produce the bytes for equivalence class &#34;c&#34;.
<span class="lno">760  </span> * Currently only handles latin1, latin9 and utf-8.
</span><span class="nop"><span class="lno"> </span>
</span><span class="nop"><span class="lno">761  </span> */
<span class="lno">762  </span>    static void
<span class="lno">763  </span>reg_equi_class(c)
</span></td><td class="ttd"><span class="lin">Line 813 to 819</span><span class="nop"><span class="lno">813  </span>/*
<span class="lno">814  </span> * Produce the bytes for equivalence class &#34;c&#34;.
<span class="lno">815  </span> * Currently only handles latin1, latin9 and utf-8.
</span><span class="add"><span class="lno">816  </span> * NOTE: When changing this function, also change nfa_emit_equi_class()
</span><span class="nop"><span class="lno">817  </span> */
<span class="lno">818  </span>    static void
<span class="lno">819  </span>reg_equi_class(c)
</span></td></tr>
<tr><td class="ttd"><span class="lin">Line 787 to 854</span><span class="nop"><span class="lno">787  </span>	switch (c)
<span class="lno">788  </span>	{
<span class="lno">789  </span>	    case &#39;A&#39;: case &#39;\300&#39;: case &#39;\301&#39;: case &#39;\302&#39;:
</span><span class="nop"><span class="lno"> </span>
<span class="lno"> </span>
</span><span class="nop"><span class="lno">790  </span>	    case &#39;\303&#39;: case &#39;\304&#39;: case &#39;\305&#39;:
<span class="lno">791  </span>		      regmbc(&#39;A&#39;); regmbc(&#39;\300&#39;); regmbc(&#39;\301&#39;);
<span class="lno">792  </span>		      regmbc(&#39;\302&#39;); regmbc(&#39;\303&#39;); regmbc(&#39;\304&#39;);
</span><span class="nop"><span class="lno">793  </span>		      regmbc(&#39;\305&#39;);
</span><span class="nop"><span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
</span><span class="nop"><span class="lno">794  </span>		      return;
<span class="lno">795  </span>	    case &#39;C&#39;: case &#39;\307&#39;:
</span><span class="nop"><span class="lno"> </span>
</span><span class="nop"><span class="lno">796  </span>		      regmbc(&#39;C&#39;); regmbc(&#39;\307&#39;);
</span><span class="nop"><span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
</span><span class="nop"><span class="lno">797  </span>		      return;
<span class="lno">798  </span>	    case &#39;E&#39;: case &#39;\310&#39;: case &#39;\311&#39;: case &#39;\312&#39;: case &#39;\313&#39;:
</span><span class="nop"><span class="lno"> </span>
<span class="lno"> </span>
</span><span class="nop"><span class="lno">799  </span>		      regmbc(&#39;E&#39;); regmbc(&#39;\310&#39;); regmbc(&#39;\311&#39;);
<span class="lno">800  </span>		      regmbc(&#39;\312&#39;); regmbc(&#39;\313&#39;);
</span><span class="nop"><span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
</span><span class="nop"><span class="lno">801  </span>		      return;
<span class="lno">802  </span>	    case &#39;I&#39;: case &#39;\314&#39;: case &#39;\315&#39;: case &#39;\316&#39;: case &#39;\317&#39;:
</span><span class="nop"><span class="lno"> </span>
<span class="lno"> </span>
</span><span class="nop"><span class="lno">803  </span>		      regmbc(&#39;I&#39;); regmbc(&#39;\314&#39;); regmbc(&#39;\315&#39;);
<span class="lno">804  </span>		      regmbc(&#39;\316&#39;); regmbc(&#39;\317&#39;);
</span><span class="nop"><span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
</span><span class="nop"><span class="lno">805  </span>		      return;
<span class="lno">806  </span>	    case &#39;N&#39;: case &#39;\321&#39;:
</span><span class="nop"><span class="lno"> </span>
<span class="lno"> </span>
</span><span class="nop"><span class="lno">807  </span>		      regmbc(&#39;N&#39;); regmbc(&#39;\321&#39;);
</span><span class="nop"><span class="lno"> </span>
<span class="lno"> </span>
</span><span class="nop"><span class="lno">808  </span>		      return;
<span class="lno">809  </span>	    case &#39;O&#39;: case &#39;\322&#39;: case &#39;\323&#39;: case &#39;\324&#39;: case &#39;\325&#39;:
</span><span class="upd"><span class="lno">810  </span>	    case &#39;\326&#39;:
</span><span class="nop"><span class="lno"> </span>
<span class="lno"> </span>
</span><span class="nop"><span class="lno">811  </span>		      regmbc(&#39;O&#39;); regmbc(&#39;\322&#39;); regmbc(&#39;\323&#39;);
<span class="lno">812  </span>		      regmbc(&#39;\324&#39;); regmbc(&#39;\325&#39;); regmbc(&#39;\326&#39;);
</span><span class="nop"><span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
</span><span class="nop"><span class="lno">813  </span>		      return;
<span class="lno">814  </span>	    case &#39;U&#39;: case &#39;\331&#39;: case &#39;\332&#39;: case &#39;\333&#39;: case &#39;\334&#39;:
</span><span class="nop"><span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
</span><span class="nop"><span class="lno">815  </span>		      regmbc(&#39;U&#39;); regmbc(&#39;\331&#39;); regmbc(&#39;\332&#39;);
<span class="lno">816  </span>		      regmbc(&#39;\333&#39;); regmbc(&#39;\334&#39;);
</span><span class="nop"><span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
</span><span class="nop"><span class="lno">817  </span>		      return;
<span class="lno">818  </span>	    case &#39;Y&#39;: case &#39;\335&#39;:
</span><span class="nop"><span class="lno"> </span>
<span class="lno"> </span>
</span><span class="nop"><span class="lno">819  </span>		      regmbc(&#39;Y&#39;); regmbc(&#39;\335&#39;);
</span><span class="nop"><span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
</span><span class="nop"><span class="lno">820  </span>		      return;
<span class="lno">821  </span>	    case &#39;a&#39;: case &#39;\340&#39;: case &#39;\341&#39;: case &#39;\342&#39;:
<span class="lno">822  </span>	    case &#39;\343&#39;: case &#39;\344&#39;: case &#39;\345&#39;:
</span><span class="nop"><span class="lno"> </span>
<span class="lno"> </span>
</span><span class="nop"><span class="lno">823  </span>		      regmbc(&#39;a&#39;); regmbc(&#39;\340&#39;); regmbc(&#39;\341&#39;);
<span class="lno">824  </span>		      regmbc(&#39;\342&#39;); regmbc(&#39;\343&#39;); regmbc(&#39;\344&#39;);
<span class="lno">825  </span>		      regmbc(&#39;\345&#39;);
</span><span class="nop"><span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
</span><span class="nop"><span class="lno">826  </span>		      return;
<span class="lno">827  </span>	    case &#39;c&#39;: case &#39;\347&#39;:
</span><span class="nop"><span class="lno"> </span>
</span><span class="nop"><span class="lno">828  </span>		      regmbc(&#39;c&#39;); regmbc(&#39;\347&#39;);
</span><span class="nop"><span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
</span><span class="nop"><span class="lno">829  </span>		      return;
<span class="lno">830  </span>	    case &#39;e&#39;: case &#39;\350&#39;: case &#39;\351&#39;: case &#39;\352&#39;: case &#39;\353&#39;:
</span><span class="nop"><span class="lno"> </span>
<span class="lno"> </span>
</span><span class="nop"><span class="lno">831  </span>		      regmbc(&#39;e&#39;); regmbc(&#39;\350&#39;); regmbc(&#39;\351&#39;);
<span class="lno">832  </span>		      regmbc(&#39;\352&#39;); regmbc(&#39;\353&#39;);
</span><span class="nop"><span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
</span><span class="nop"><span class="lno">833  </span>		      return;
<span class="lno">834  </span>	    case &#39;i&#39;: case &#39;\354&#39;: case &#39;\355&#39;: case &#39;\356&#39;: case &#39;\357&#39;:
</span><span class="nop"><span class="lno"> </span>
<span class="lno"> </span>
</span><span class="nop"><span class="lno">835  </span>		      regmbc(&#39;i&#39;); regmbc(&#39;\354&#39;); regmbc(&#39;\355&#39;);
<span class="lno">836  </span>		      regmbc(&#39;\356&#39;); regmbc(&#39;\357&#39;);
</span><span class="nop"><span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
</span><span class="nop"><span class="lno">837  </span>		      return;
<span class="lno">838  </span>	    case &#39;n&#39;: case &#39;\361&#39;:
</span><span class="nop"><span class="lno"> </span>
<span class="lno"> </span>
</span><span class="nop"><span class="lno">839  </span>		      regmbc(&#39;n&#39;); regmbc(&#39;\361&#39;);
</span><span class="nop"><span class="lno"> </span>
<span class="lno"> </span>
</span><span class="nop"><span class="lno">840  </span>		      return;
<span class="lno">841  </span>	    case &#39;o&#39;: case &#39;\362&#39;: case &#39;\363&#39;: case &#39;\364&#39;: case &#39;\365&#39;:
</span><span class="upd"><span class="lno">842  </span>	    case &#39;\366&#39;:
</span><span class="nop"><span class="lno"> </span>
<span class="lno"> </span>
</span><span class="nop"><span class="lno">843  </span>		      regmbc(&#39;o&#39;); regmbc(&#39;\362&#39;); regmbc(&#39;\363&#39;);
<span class="lno">844  </span>		      regmbc(&#39;\364&#39;); regmbc(&#39;\365&#39;); regmbc(&#39;\366&#39;);
</span><span class="nop"><span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
</span><span class="nop"><span class="lno">845  </span>		      return;
<span class="lno">846  </span>	    case &#39;u&#39;: case &#39;\371&#39;: case &#39;\372&#39;: case &#39;\373&#39;: case &#39;\374&#39;:
</span><span class="nop"><span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
</span><span class="nop"><span class="lno">847  </span>		      regmbc(&#39;u&#39;); regmbc(&#39;\371&#39;); regmbc(&#39;\372&#39;);
<span class="lno">848  </span>		      regmbc(&#39;\373&#39;); regmbc(&#39;\374&#39;);
</span><span class="nop"><span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
</span><span class="nop"><span class="lno">849  </span>		      return;
<span class="lno">850  </span>	    case &#39;y&#39;: case &#39;\375&#39;: case &#39;\377&#39;:
</span><span class="nop"><span class="lno"> </span>
<span class="lno"> </span>
</span><span class="nop"><span class="lno">851  </span>		      regmbc(&#39;y&#39;); regmbc(&#39;\375&#39;); regmbc(&#39;\377&#39;);
</span><span class="nop"><span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
</span><span class="nop"><span class="lno">852  </span>		      return;
<span class="lno">853  </span>	}
<span class="lno">854  </span>#endif
</span></td><td class="ttd"><span class="lin">Line 843 to 1137</span><span class="nop"><span class="lno">843  </span>	switch (c)
<span class="lno">844  </span>	{
<span class="lno">845  </span>	    case &#39;A&#39;: case &#39;\300&#39;: case &#39;\301&#39;: case &#39;\302&#39;:
</span><span class="add"><span class="lno">846  </span>	    CASEMBC(0x100) CASEMBC(0x102) CASEMBC(0x104) CASEMBC(0x1cd)
<span class="lno">847  </span>	    CASEMBC(0x1de) CASEMBC(0x1e0) CASEMBC(0x1ea2)
</span><span class="nop"><span class="lno">848  </span>	    case &#39;\303&#39;: case &#39;\304&#39;: case &#39;\305&#39;:
<span class="lno">849  </span>		      regmbc(&#39;A&#39;); regmbc(&#39;\300&#39;); regmbc(&#39;\301&#39;);
<span class="lno">850  </span>		      regmbc(&#39;\302&#39;); regmbc(&#39;\303&#39;); regmbc(&#39;\304&#39;);
</span><span class="nop"><span class="lno">851  </span>		      regmbc(&#39;\305&#39;);
</span><span class="add"><span class="lno">852  </span>		      REGMBC(0x100) REGMBC(0x102) REGMBC(0x104)
<span class="lno">853  </span>		      REGMBC(0x1cd) REGMBC(0x1de) REGMBC(0x1e0)
<span class="lno">854  </span>		      REGMBC(0x1ea2)
<span class="lno">855  </span>		      return;
<span class="lno">856  </span>	    case &#39;B&#39;: CASEMBC(0x1e02) CASEMBC(0x1e06)
<span class="lno">857  </span>		      regmbc(&#39;B&#39;); REGMBC(0x1e02) REGMBC(0x1e06)
</span><span class="nop"><span class="lno">858  </span>		      return;
<span class="lno">859  </span>	    case &#39;C&#39;: case &#39;\307&#39;:
</span><span class="add"><span class="lno">860  </span>	    CASEMBC(0x106) CASEMBC(0x108) CASEMBC(0x10a) CASEMBC(0x10c)
</span><span class="nop"><span class="lno">861  </span>		      regmbc(&#39;C&#39;); regmbc(&#39;\307&#39;);
</span><span class="add"><span class="lno">862  </span>		      REGMBC(0x106) REGMBC(0x108) REGMBC(0x10a)
<span class="lno">863  </span>		      REGMBC(0x10c)
<span class="lno">864  </span>		      return;
<span class="lno">865  </span>	    case &#39;D&#39;: CASEMBC(0x10e) CASEMBC(0x110) CASEMBC(0x1e0a)
<span class="lno">866  </span>	    CASEMBC(0x1e0e) CASEMBC(0x1e10)
<span class="lno">867  </span>		      regmbc(&#39;D&#39;); REGMBC(0x10e) REGMBC(0x110)
<span class="lno">868  </span>		      REGMBC(0x1e0a) REGMBC(0x1e0e) REGMBC(0x1e10)
</span><span class="nop"><span class="lno">869  </span>		      return;
<span class="lno">870  </span>	    case &#39;E&#39;: case &#39;\310&#39;: case &#39;\311&#39;: case &#39;\312&#39;: case &#39;\313&#39;:
</span><span class="add"><span class="lno">871  </span>	    CASEMBC(0x112) CASEMBC(0x114) CASEMBC(0x116) CASEMBC(0x118)
<span class="lno">872  </span>	    CASEMBC(0x11a) CASEMBC(0x1eba) CASEMBC(0x1ebc)
</span><span class="nop"><span class="lno">873  </span>		      regmbc(&#39;E&#39;); regmbc(&#39;\310&#39;); regmbc(&#39;\311&#39;);
<span class="lno">874  </span>		      regmbc(&#39;\312&#39;); regmbc(&#39;\313&#39;);
</span><span class="add"><span class="lno">875  </span>		      REGMBC(0x112) REGMBC(0x114) REGMBC(0x116)
<span class="lno">876  </span>		      REGMBC(0x118) REGMBC(0x11a) REGMBC(0x1eba)
<span class="lno">877  </span>		      REGMBC(0x1ebc)
<span class="lno">878  </span>		      return;
<span class="lno">879  </span>	    case &#39;F&#39;: CASEMBC(0x1e1e)
<span class="lno">880  </span>		      regmbc(&#39;F&#39;); REGMBC(0x1e1e)
<span class="lno">881  </span>		      return;
<span class="lno">882  </span>	    case &#39;G&#39;: CASEMBC(0x11c) CASEMBC(0x11e) CASEMBC(0x120)
<span class="lno">883  </span>	    CASEMBC(0x122) CASEMBC(0x1e4) CASEMBC(0x1e6) CASEMBC(0x1f4)
<span class="lno">884  </span>	    CASEMBC(0x1e20)
<span class="lno">885  </span>		      regmbc(&#39;G&#39;); REGMBC(0x11c) REGMBC(0x11e)
<span class="lno">886  </span>		      REGMBC(0x120) REGMBC(0x122) REGMBC(0x1e4)
<span class="lno">887  </span>		      REGMBC(0x1e6) REGMBC(0x1f4) REGMBC(0x1e20)
<span class="lno">888  </span>		      return;
<span class="lno">889  </span>	    case &#39;H&#39;: CASEMBC(0x124) CASEMBC(0x126) CASEMBC(0x1e22)
<span class="lno">890  </span>	    CASEMBC(0x1e26) CASEMBC(0x1e28)
<span class="lno">891  </span>		      regmbc(&#39;H&#39;); REGMBC(0x124) REGMBC(0x126)
<span class="lno">892  </span>		      REGMBC(0x1e22) REGMBC(0x1e26) REGMBC(0x1e28)
</span><span class="nop"><span class="lno">893  </span>		      return;
<span class="lno">894  </span>	    case &#39;I&#39;: case &#39;\314&#39;: case &#39;\315&#39;: case &#39;\316&#39;: case &#39;\317&#39;:
</span><span class="add"><span class="lno">895  </span>	    CASEMBC(0x128) CASEMBC(0x12a) CASEMBC(0x12c) CASEMBC(0x12e)
<span class="lno">896  </span>	    CASEMBC(0x130) CASEMBC(0x1cf) CASEMBC(0x1ec8)
</span><span class="nop"><span class="lno">897  </span>		      regmbc(&#39;I&#39;); regmbc(&#39;\314&#39;); regmbc(&#39;\315&#39;);
<span class="lno">898  </span>		      regmbc(&#39;\316&#39;); regmbc(&#39;\317&#39;);
</span><span class="add"><span class="lno">899  </span>		      REGMBC(0x128) REGMBC(0x12a) REGMBC(0x12c)
<span class="lno">900  </span>		      REGMBC(0x12e) REGMBC(0x130) REGMBC(0x1cf)
<span class="lno">901  </span>		      REGMBC(0x1ec8)
<span class="lno">902  </span>		      return;
<span class="lno">903  </span>	    case &#39;J&#39;: CASEMBC(0x134)
<span class="lno">904  </span>		      regmbc(&#39;J&#39;); REGMBC(0x134)
<span class="lno">905  </span>		      return;
<span class="lno">906  </span>	    case &#39;K&#39;: CASEMBC(0x136) CASEMBC(0x1e8) CASEMBC(0x1e30)
<span class="lno">907  </span>	    CASEMBC(0x1e34)
<span class="lno">908  </span>		      regmbc(&#39;K&#39;); REGMBC(0x136) REGMBC(0x1e8)
<span class="lno">909  </span>		      REGMBC(0x1e30) REGMBC(0x1e34)
<span class="lno">910  </span>		      return;
<span class="lno">911  </span>	    case &#39;L&#39;: CASEMBC(0x139) CASEMBC(0x13b) CASEMBC(0x13d)
<span class="lno">912  </span>	    CASEMBC(0x13f) CASEMBC(0x141) CASEMBC(0x1e3a)
<span class="lno">913  </span>		      regmbc(&#39;L&#39;); REGMBC(0x139) REGMBC(0x13b)
<span class="lno">914  </span>		      REGMBC(0x13d) REGMBC(0x13f) REGMBC(0x141)
<span class="lno">915  </span>		      REGMBC(0x1e3a)
<span class="lno">916  </span>		      return;
<span class="lno">917  </span>	    case &#39;M&#39;: CASEMBC(0x1e3e) CASEMBC(0x1e40)
<span class="lno">918  </span>		      regmbc(&#39;M&#39;); REGMBC(0x1e3e) REGMBC(0x1e40)
</span><span class="nop"><span class="lno">919  </span>		      return;
<span class="lno">920  </span>	    case &#39;N&#39;: case &#39;\321&#39;:
</span><span class="add"><span class="lno">921  </span>	    CASEMBC(0x143) CASEMBC(0x145) CASEMBC(0x147) CASEMBC(0x1e44)
<span class="lno">922  </span>	    CASEMBC(0x1e48)
</span><span class="nop"><span class="lno">923  </span>		      regmbc(&#39;N&#39;); regmbc(&#39;\321&#39;);
</span><span class="add"><span class="lno">924  </span>		      REGMBC(0x143) REGMBC(0x145) REGMBC(0x147)
<span class="lno">925  </span>		      REGMBC(0x1e44) REGMBC(0x1e48)
</span><span class="nop"><span class="lno">926  </span>		      return;
<span class="lno">927  </span>	    case &#39;O&#39;: case &#39;\322&#39;: case &#39;\323&#39;: case &#39;\324&#39;: case &#39;\325&#39;:
</span><span class="upd"><span class="lno">928  </span>	    case &#39;\326&#39;:<span class="chg"> case &#39;\330&#39;:</span>
</span><span class="add"><span class="lno">929  </span>	    CASEMBC(0x14c) CASEMBC(0x14e) CASEMBC(0x150) CASEMBC(0x1a0)
<span class="lno">930  </span>	    CASEMBC(0x1d1) CASEMBC(0x1ea) CASEMBC(0x1ec) CASEMBC(0x1ece)
</span><span class="nop"><span class="lno">931  </span>		      regmbc(&#39;O&#39;); regmbc(&#39;\322&#39;); regmbc(&#39;\323&#39;);
<span class="lno">932  </span>		      regmbc(&#39;\324&#39;); regmbc(&#39;\325&#39;); regmbc(&#39;\326&#39;);
</span><span class="add"><span class="lno">933  </span>		      regmbc(&#39;\330&#39;);
<span class="lno">934  </span>		      REGMBC(0x14c) REGMBC(0x14e) REGMBC(0x150)
<span class="lno">935  </span>		      REGMBC(0x1a0) REGMBC(0x1d1) REGMBC(0x1ea)
<span class="lno">936  </span>		      REGMBC(0x1ec) REGMBC(0x1ece)
<span class="lno">937  </span>		      return;
<span class="lno">938  </span>	    case &#39;P&#39;: case 0x1e54: case 0x1e56:
<span class="lno">939  </span>		      regmbc(&#39;P&#39;); REGMBC(0x1e54) REGMBC(0x1e56)
<span class="lno">940  </span>		      return;
<span class="lno">941  </span>	    case &#39;R&#39;: CASEMBC(0x154) CASEMBC(0x156) CASEMBC(0x158)
<span class="lno">942  </span>	    CASEMBC(0x1e58) CASEMBC(0x1e5e)
<span class="lno">943  </span>		      regmbc(&#39;R&#39;); REGMBC(0x154) REGMBC(0x156) REGMBC(0x158)
<span class="lno">944  </span>		      REGMBC(0x1e58) REGMBC(0x1e5e)
<span class="lno">945  </span>		      return;
<span class="lno">946  </span>	    case &#39;S&#39;: CASEMBC(0x15a) CASEMBC(0x15c) CASEMBC(0x15e)
<span class="lno">947  </span>	    CASEMBC(0x160) CASEMBC(0x1e60)
<span class="lno">948  </span>		      regmbc(&#39;S&#39;); REGMBC(0x15a) REGMBC(0x15c)
<span class="lno">949  </span>		      REGMBC(0x15e) REGMBC(0x160) REGMBC(0x1e60)
<span class="lno">950  </span>		      return;
<span class="lno">951  </span>	    case &#39;T&#39;: CASEMBC(0x162) CASEMBC(0x164) CASEMBC(0x166)
<span class="lno">952  </span>	    CASEMBC(0x1e6a) CASEMBC(0x1e6e)
<span class="lno">953  </span>		      regmbc(&#39;T&#39;); REGMBC(0x162) REGMBC(0x164)
<span class="lno">954  </span>		      REGMBC(0x166) REGMBC(0x1e6a) REGMBC(0x1e6e)
</span><span class="nop"><span class="lno">955  </span>		      return;
<span class="lno">956  </span>	    case &#39;U&#39;: case &#39;\331&#39;: case &#39;\332&#39;: case &#39;\333&#39;: case &#39;\334&#39;:
</span><span class="add"><span class="lno">957  </span>	    CASEMBC(0x168) CASEMBC(0x16a) CASEMBC(0x16c) CASEMBC(0x16e)
<span class="lno">958  </span>	    CASEMBC(0x170) CASEMBC(0x172) CASEMBC(0x1af) CASEMBC(0x1d3)
<span class="lno">959  </span>	    CASEMBC(0x1ee6)
</span><span class="nop"><span class="lno">960  </span>		      regmbc(&#39;U&#39;); regmbc(&#39;\331&#39;); regmbc(&#39;\332&#39;);
<span class="lno">961  </span>		      regmbc(&#39;\333&#39;); regmbc(&#39;\334&#39;);
</span><span class="add"><span class="lno">962  </span>		      REGMBC(0x168) REGMBC(0x16a) REGMBC(0x16c)
<span class="lno">963  </span>		      REGMBC(0x16e) REGMBC(0x170) REGMBC(0x172)
<span class="lno">964  </span>		      REGMBC(0x1af) REGMBC(0x1d3) REGMBC(0x1ee6)
<span class="lno">965  </span>		      return;
<span class="lno">966  </span>	    case &#39;V&#39;: CASEMBC(0x1e7c)
<span class="lno">967  </span>		      regmbc(&#39;V&#39;); REGMBC(0x1e7c)
<span class="lno">968  </span>		      return;
<span class="lno">969  </span>	    case &#39;W&#39;: CASEMBC(0x174) CASEMBC(0x1e80) CASEMBC(0x1e82)
<span class="lno">970  </span>	    CASEMBC(0x1e84) CASEMBC(0x1e86)
<span class="lno">971  </span>		      regmbc(&#39;W&#39;); REGMBC(0x174) REGMBC(0x1e80)
<span class="lno">972  </span>		      REGMBC(0x1e82) REGMBC(0x1e84) REGMBC(0x1e86)
<span class="lno">973  </span>		      return;
<span class="lno">974  </span>	    case &#39;X&#39;: CASEMBC(0x1e8a) CASEMBC(0x1e8c)
<span class="lno">975  </span>		      regmbc(&#39;X&#39;); REGMBC(0x1e8a) REGMBC(0x1e8c)
</span><span class="nop"><span class="lno">976  </span>		      return;
<span class="lno">977  </span>	    case &#39;Y&#39;: case &#39;\335&#39;:
</span><span class="add"><span class="lno">978  </span>	    CASEMBC(0x176) CASEMBC(0x178) CASEMBC(0x1e8e) CASEMBC(0x1ef2)
<span class="lno">979  </span>	    CASEMBC(0x1ef6) CASEMBC(0x1ef8)
</span><span class="nop"><span class="lno">980  </span>		      regmbc(&#39;Y&#39;); regmbc(&#39;\335&#39;);
</span><span class="add"><span class="lno">981  </span>		      REGMBC(0x176) REGMBC(0x178) REGMBC(0x1e8e)
<span class="lno">982  </span>		      REGMBC(0x1ef2) REGMBC(0x1ef6) REGMBC(0x1ef8)
<span class="lno">983  </span>		      return;
<span class="lno">984  </span>	    case &#39;Z&#39;: CASEMBC(0x179) CASEMBC(0x17b) CASEMBC(0x17d)
<span class="lno">985  </span>	    CASEMBC(0x1b5) CASEMBC(0x1e90) CASEMBC(0x1e94)
<span class="lno">986  </span>		      regmbc(&#39;Z&#39;); REGMBC(0x179) REGMBC(0x17b)
<span class="lno">987  </span>		      REGMBC(0x17d) REGMBC(0x1b5) REGMBC(0x1e90)
<span class="lno">988  </span>		      REGMBC(0x1e94)
</span><span class="nop"><span class="lno">989  </span>		      return;
<span class="lno">990  </span>	    case &#39;a&#39;: case &#39;\340&#39;: case &#39;\341&#39;: case &#39;\342&#39;:
<span class="lno">991  </span>	    case &#39;\343&#39;: case &#39;\344&#39;: case &#39;\345&#39;:
</span><span class="add"><span class="lno">992  </span>	    CASEMBC(0x101) CASEMBC(0x103) CASEMBC(0x105) CASEMBC(0x1ce)
<span class="lno">993  </span>	    CASEMBC(0x1df) CASEMBC(0x1e1) CASEMBC(0x1ea3)
</span><span class="nop"><span class="lno">994  </span>		      regmbc(&#39;a&#39;); regmbc(&#39;\340&#39;); regmbc(&#39;\341&#39;);
<span class="lno">995  </span>		      regmbc(&#39;\342&#39;); regmbc(&#39;\343&#39;); regmbc(&#39;\344&#39;);
<span class="lno">996  </span>		      regmbc(&#39;\345&#39;);
</span><span class="add"><span class="lno">997  </span>		      REGMBC(0x101) REGMBC(0x103) REGMBC(0x105)
<span class="lno">998  </span>		      REGMBC(0x1ce) REGMBC(0x1df) REGMBC(0x1e1)
<span class="lno">999  </span>		      REGMBC(0x1ea3)
<span class="lno">1000 </span>		      return;
<span class="lno">1001 </span>	    case &#39;b&#39;: CASEMBC(0x1e03) CASEMBC(0x1e07)
<span class="lno">1002 </span>		      regmbc(&#39;b&#39;); REGMBC(0x1e03) REGMBC(0x1e07)
</span><span class="nop"><span class="lno">1003 </span>		      return;
<span class="lno">1004 </span>	    case &#39;c&#39;: case &#39;\347&#39;:
</span><span class="add"><span class="lno">1005 </span>	    CASEMBC(0x107) CASEMBC(0x109) CASEMBC(0x10b) CASEMBC(0x10d)
</span><span class="nop"><span class="lno">1006 </span>		      regmbc(&#39;c&#39;); regmbc(&#39;\347&#39;);
</span><span class="add"><span class="lno">1007 </span>		      REGMBC(0x107) REGMBC(0x109) REGMBC(0x10b)
<span class="lno">1008 </span>		      REGMBC(0x10d)
<span class="lno">1009 </span>		      return;
<span class="lno">1010 </span>	    case &#39;d&#39;: CASEMBC(0x10f) CASEMBC(0x111) CASEMBC(0x1d0b)
<span class="lno">1011 </span>	    CASEMBC(0x1e11)
<span class="lno">1012 </span>		      regmbc(&#39;d&#39;); REGMBC(0x10f) REGMBC(0x111)
<span class="lno">1013 </span>		      REGMBC(0x1e0b) REGMBC(0x01e0f) REGMBC(0x1e11)
</span><span class="nop"><span class="lno">1014 </span>		      return;
<span class="lno">1015 </span>	    case &#39;e&#39;: case &#39;\350&#39;: case &#39;\351&#39;: case &#39;\352&#39;: case &#39;\353&#39;:
</span><span class="add"><span class="lno">1016 </span>	    CASEMBC(0x113) CASEMBC(0x115) CASEMBC(0x117) CASEMBC(0x119)
<span class="lno">1017 </span>	    CASEMBC(0x11b) CASEMBC(0x1ebb) CASEMBC(0x1ebd)
</span><span class="nop"><span class="lno">1018 </span>		      regmbc(&#39;e&#39;); regmbc(&#39;\350&#39;); regmbc(&#39;\351&#39;);
<span class="lno">1019 </span>		      regmbc(&#39;\352&#39;); regmbc(&#39;\353&#39;);
</span><span class="add"><span class="lno">1020 </span>		      REGMBC(0x113) REGMBC(0x115) REGMBC(0x117)
<span class="lno">1021 </span>		      REGMBC(0x119) REGMBC(0x11b) REGMBC(0x1ebb)
<span class="lno">1022 </span>		      REGMBC(0x1ebd)
<span class="lno">1023 </span>		      return;
<span class="lno">1024 </span>	    case &#39;f&#39;: CASEMBC(0x1e1f)
<span class="lno">1025 </span>		      regmbc(&#39;f&#39;); REGMBC(0x1e1f)
<span class="lno">1026 </span>		      return;
<span class="lno">1027 </span>	    case &#39;g&#39;: CASEMBC(0x11d) CASEMBC(0x11f) CASEMBC(0x121)
<span class="lno">1028 </span>	    CASEMBC(0x123) CASEMBC(0x1e5) CASEMBC(0x1e7) CASEMBC(0x1f5)
<span class="lno">1029 </span>	    CASEMBC(0x1e21)
<span class="lno">1030 </span>		      regmbc(&#39;g&#39;); REGMBC(0x11d) REGMBC(0x11f)
<span class="lno">1031 </span>		      REGMBC(0x121) REGMBC(0x123) REGMBC(0x1e5)
<span class="lno">1032 </span>		      REGMBC(0x1e7) REGMBC(0x1f5) REGMBC(0x1e21)
<span class="lno">1033 </span>		      return;
<span class="lno">1034 </span>	    case &#39;h&#39;: CASEMBC(0x125) CASEMBC(0x127) CASEMBC(0x1e23)
<span class="lno">1035 </span>	    CASEMBC(0x1e27) CASEMBC(0x1e29) CASEMBC(0x1e96)
<span class="lno">1036 </span>		      regmbc(&#39;h&#39;); REGMBC(0x125) REGMBC(0x127)
<span class="lno">1037 </span>		      REGMBC(0x1e23) REGMBC(0x1e27) REGMBC(0x1e29)
<span class="lno">1038 </span>		      REGMBC(0x1e96)
</span><span class="nop"><span class="lno">1039 </span>		      return;
<span class="lno">1040 </span>	    case &#39;i&#39;: case &#39;\354&#39;: case &#39;\355&#39;: case &#39;\356&#39;: case &#39;\357&#39;:
</span><span class="add"><span class="lno">1041 </span>	    CASEMBC(0x129) CASEMBC(0x12b) CASEMBC(0x12d) CASEMBC(0x12f)
<span class="lno">1042 </span>	    CASEMBC(0x1d0) CASEMBC(0x1ec9)
</span><span class="nop"><span class="lno">1043 </span>		      regmbc(&#39;i&#39;); regmbc(&#39;\354&#39;); regmbc(&#39;\355&#39;);
<span class="lno">1044 </span>		      regmbc(&#39;\356&#39;); regmbc(&#39;\357&#39;);
</span><span class="add"><span class="lno">1045 </span>		      REGMBC(0x129) REGMBC(0x12b) REGMBC(0x12d)
<span class="lno">1046 </span>		      REGMBC(0x12f) REGMBC(0x1d0) REGMBC(0x1ec9)
<span class="lno">1047 </span>		      return;
<span class="lno">1048 </span>	    case &#39;j&#39;: CASEMBC(0x135) CASEMBC(0x1f0)
<span class="lno">1049 </span>		      regmbc(&#39;j&#39;); REGMBC(0x135) REGMBC(0x1f0)
<span class="lno">1050 </span>		      return;
<span class="lno">1051 </span>	    case &#39;k&#39;: CASEMBC(0x137) CASEMBC(0x1e9) CASEMBC(0x1e31)
<span class="lno">1052 </span>	    CASEMBC(0x1e35)
<span class="lno">1053 </span>		      regmbc(&#39;k&#39;); REGMBC(0x137) REGMBC(0x1e9)
<span class="lno">1054 </span>		      REGMBC(0x1e31) REGMBC(0x1e35)
<span class="lno">1055 </span>		      return;
<span class="lno">1056 </span>	    case &#39;l&#39;: CASEMBC(0x13a) CASEMBC(0x13c) CASEMBC(0x13e)
<span class="lno">1057 </span>	    CASEMBC(0x140) CASEMBC(0x142) CASEMBC(0x1e3b)
<span class="lno">1058 </span>		      regmbc(&#39;l&#39;); REGMBC(0x13a) REGMBC(0x13c)
<span class="lno">1059 </span>		      REGMBC(0x13e) REGMBC(0x140) REGMBC(0x142)
<span class="lno">1060 </span>		      REGMBC(0x1e3b)
<span class="lno">1061 </span>		      return;
<span class="lno">1062 </span>	    case &#39;m&#39;: CASEMBC(0x1e3f) CASEMBC(0x1e41)
<span class="lno">1063 </span>		      regmbc(&#39;m&#39;); REGMBC(0x1e3f) REGMBC(0x1e41)
</span><span class="nop"><span class="lno">1064 </span>		      return;
<span class="lno">1065 </span>	    case &#39;n&#39;: case &#39;\361&#39;:
</span><span class="add"><span class="lno">1066 </span>	    CASEMBC(0x144) CASEMBC(0x146) CASEMBC(0x148) CASEMBC(0x149)
<span class="lno">1067 </span>	    CASEMBC(0x1e45) CASEMBC(0x1e49)
</span><span class="nop"><span class="lno">1068 </span>		      regmbc(&#39;n&#39;); regmbc(&#39;\361&#39;);
</span><span class="add"><span class="lno">1069 </span>		      REGMBC(0x144) REGMBC(0x146) REGMBC(0x148)
<span class="lno">1070 </span>		      REGMBC(0x149) REGMBC(0x1e45) REGMBC(0x1e49)
</span><span class="nop"><span class="lno">1071 </span>		      return;
<span class="lno">1072 </span>	    case &#39;o&#39;: case &#39;\362&#39;: case &#39;\363&#39;: case &#39;\364&#39;: case &#39;\365&#39;:
</span><span class="upd"><span class="lno">1073 </span>	    case &#39;\366&#39;:<span class="chg"> case &#39;\370&#39;:</span>
</span><span class="add"><span class="lno">1074 </span>	    CASEMBC(0x14d) CASEMBC(0x14f) CASEMBC(0x151) CASEMBC(0x1a1)
<span class="lno">1075 </span>	    CASEMBC(0x1d2) CASEMBC(0x1eb) CASEMBC(0x1ed) CASEMBC(0x1ecf)
</span><span class="nop"><span class="lno">1076 </span>		      regmbc(&#39;o&#39;); regmbc(&#39;\362&#39;); regmbc(&#39;\363&#39;);
<span class="lno">1077 </span>		      regmbc(&#39;\364&#39;); regmbc(&#39;\365&#39;); regmbc(&#39;\366&#39;);
</span><span class="add"><span class="lno">1078 </span>		      regmbc(&#39;\370&#39;);
<span class="lno">1079 </span>		      REGMBC(0x14d) REGMBC(0x14f) REGMBC(0x151)
<span class="lno">1080 </span>		      REGMBC(0x1a1) REGMBC(0x1d2) REGMBC(0x1eb)
<span class="lno">1081 </span>		      REGMBC(0x1ed) REGMBC(0x1ecf)
<span class="lno">1082 </span>		      return;
<span class="lno">1083 </span>	    case &#39;p&#39;: CASEMBC(0x1e55) CASEMBC(0x1e57)
<span class="lno">1084 </span>		      regmbc(&#39;p&#39;); REGMBC(0x1e55) REGMBC(0x1e57)
<span class="lno">1085 </span>		      return;
<span class="lno">1086 </span>	    case &#39;r&#39;: CASEMBC(0x155) CASEMBC(0x157) CASEMBC(0x159)
<span class="lno">1087 </span>	    CASEMBC(0x1e59) CASEMBC(0x1e5f)
<span class="lno">1088 </span>		      regmbc(&#39;r&#39;); REGMBC(0x155) REGMBC(0x157) REGMBC(0x159)
<span class="lno">1089 </span>		      REGMBC(0x1e59) REGMBC(0x1e5f)
<span class="lno">1090 </span>		      return;
<span class="lno">1091 </span>	    case &#39;s&#39;: CASEMBC(0x15b) CASEMBC(0x15d) CASEMBC(0x15f)
<span class="lno">1092 </span>	    CASEMBC(0x161) CASEMBC(0x1e61)
<span class="lno">1093 </span>		      regmbc(&#39;s&#39;); REGMBC(0x15b) REGMBC(0x15d)
<span class="lno">1094 </span>		      REGMBC(0x15f) REGMBC(0x161) REGMBC(0x1e61)
<span class="lno">1095 </span>		      return;
<span class="lno">1096 </span>	    case &#39;t&#39;: CASEMBC(0x163) CASEMBC(0x165) CASEMBC(0x167)
<span class="lno">1097 </span>	    CASEMBC(0x1e6b) CASEMBC(0x1e6f) CASEMBC(0x1e97)
<span class="lno">1098 </span>		      regmbc(&#39;t&#39;); REGMBC(0x163) REGMBC(0x165) REGMBC(0x167)
<span class="lno">1099 </span>		      REGMBC(0x1e6b) REGMBC(0x1e6f) REGMBC(0x1e97)
</span><span class="nop"><span class="lno">1100 </span>		      return;
<span class="lno">1101 </span>	    case &#39;u&#39;: case &#39;\371&#39;: case &#39;\372&#39;: case &#39;\373&#39;: case &#39;\374&#39;:
</span><span class="add"><span class="lno">1102 </span>	    CASEMBC(0x169) CASEMBC(0x16b) CASEMBC(0x16d) CASEMBC(0x16f)
<span class="lno">1103 </span>	    CASEMBC(0x171) CASEMBC(0x173) CASEMBC(0x1b0) CASEMBC(0x1d4)
<span class="lno">1104 </span>	    CASEMBC(0x1ee7)
</span><span class="nop"><span class="lno">1105 </span>		      regmbc(&#39;u&#39;); regmbc(&#39;\371&#39;); regmbc(&#39;\372&#39;);
<span class="lno">1106 </span>		      regmbc(&#39;\373&#39;); regmbc(&#39;\374&#39;);
</span><span class="add"><span class="lno">1107 </span>		      REGMBC(0x169) REGMBC(0x16b) REGMBC(0x16d)
<span class="lno">1108 </span>		      REGMBC(0x16f) REGMBC(0x171) REGMBC(0x173)
<span class="lno">1109 </span>		      REGMBC(0x1b0) REGMBC(0x1d4) REGMBC(0x1ee7)
<span class="lno">1110 </span>		      return;
<span class="lno">1111 </span>	    case &#39;v&#39;: CASEMBC(0x1e7d)
<span class="lno">1112 </span>		      regmbc(&#39;v&#39;); REGMBC(0x1e7d)
<span class="lno">1113 </span>		      return;
<span class="lno">1114 </span>	    case &#39;w&#39;: CASEMBC(0x175) CASEMBC(0x1e81) CASEMBC(0x1e83)
<span class="lno">1115 </span>	    CASEMBC(0x1e85) CASEMBC(0x1e87) CASEMBC(0x1e98)
<span class="lno">1116 </span>		      regmbc(&#39;w&#39;); REGMBC(0x175) REGMBC(0x1e81)
<span class="lno">1117 </span>		      REGMBC(0x1e83) REGMBC(0x1e85) REGMBC(0x1e87)
<span class="lno">1118 </span>		      REGMBC(0x1e98)
<span class="lno">1119 </span>		      return;
<span class="lno">1120 </span>	    case &#39;x&#39;: CASEMBC(0x1e8b) CASEMBC(0x1e8d)
<span class="lno">1121 </span>		      regmbc(&#39;x&#39;); REGMBC(0x1e8b) REGMBC(0x1e8d)
</span><span class="nop"><span class="lno">1122 </span>		      return;
<span class="lno">1123 </span>	    case &#39;y&#39;: case &#39;\375&#39;: case &#39;\377&#39;:
</span><span class="add"><span class="lno">1124 </span>	    CASEMBC(0x177) CASEMBC(0x1e8f) CASEMBC(0x1e99)
<span class="lno">1125 </span>	    CASEMBC(0x1ef3) CASEMBC(0x1ef7) CASEMBC(0x1ef9)
</span><span class="nop"><span class="lno">1126 </span>		      regmbc(&#39;y&#39;); regmbc(&#39;\375&#39;); regmbc(&#39;\377&#39;);
</span><span class="add"><span class="lno">1127 </span>		      REGMBC(0x177) REGMBC(0x1e8f) REGMBC(0x1e99)
<span class="lno">1128 </span>		      REGMBC(0x1ef3) REGMBC(0x1ef7) REGMBC(0x1ef9)
<span class="lno">1129 </span>		      return;
<span class="lno">1130 </span>	    case &#39;z&#39;: CASEMBC(0x17a) CASEMBC(0x17c) CASEMBC(0x17e)
<span class="lno">1131 </span>	    CASEMBC(0x1b6) CASEMBC(0x1e91) CASEMBC(0x1e95)
<span class="lno">1132 </span>		      regmbc(&#39;z&#39;); REGMBC(0x17a) REGMBC(0x17c)
<span class="lno">1133 </span>		      REGMBC(0x17e) REGMBC(0x1b6) REGMBC(0x1e91)
<span class="lno">1134 </span>		      REGMBC(0x1e95)
</span><span class="nop"><span class="lno">1135 </span>		      return;
<span class="lno">1136 </span>	}
<span class="lno">1137 </span>#endif
</span></td></tr>
<tr><td class="ttd"><span class="lin">Line 891 to 896</span><span class="nop"><span class="lno">891  </span>    return 0;
<span class="lno">892  </span>}
<span class="lno">893  </span>
</span><span class="nop"><span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
</span><span class="nop"><span class="lno">894  </span>
<span class="lno">895  </span>/*
<span class="lno">896  </span> * Skip over a &#34;[]&#34; range.
</span></td><td class="ttd"><span class="lin">Line 1174 to 1189</span><span class="nop"><span class="lno">1174 </span>    return 0;
<span class="lno">1175 </span>}
<span class="lno">1176 </span>
</span><span class="add"><span class="lno">1177 </span>static void get_cpo_flags __ARGS((void));
<span class="lno">1178 </span>static int reg_cpo_lit; /* &#39;cpoptions&#39; contains &#39;l&#39; flag */
<span class="lno">1179 </span>static int reg_cpo_bsl; /* &#39;cpoptions&#39; contains &#39;\&#39; flag */
<span class="lno">1180 </span>
<span class="lno">1181 </span>    static void
<span class="lno">1182 </span>get_cpo_flags()
<span class="lno">1183 </span>{
<span class="lno">1184 </span>    reg_cpo_lit = vim_strchr(p_cpo, CPO_LITERAL) != NULL;
<span class="lno">1185 </span>    reg_cpo_bsl = vim_strchr(p_cpo, CPO_BACKSL) != NULL;
<span class="lno">1186 </span>}
</span><span class="nop"><span class="lno">1187 </span>
<span class="lno">1188 </span>/*
<span class="lno">1189 </span> * Skip over a &#34;[]&#34; range.
</span></td></tr>
<tr><td class="ttd"><span class="lin">Line 901 to 915</span><span class="nop"><span class="lno">901  </span>skip_anyof(p)
<span class="lno">902  </span>    char_u	*p;
<span class="lno">903  </span>{
</span><span class="del"><span class="lno">904  </span>    int		cpo_lit;	/* &#39;cpoptions&#39; contains &#39;l&#39; flag */
<span class="lno">905  </span>    int		cpo_bsl;	/* &#39;cpoptions&#39; contains &#39;\&#39; flag */
</span><span class="nop"><span class="lno">906  </span>#ifdef FEAT_MBYTE
<span class="lno">907  </span>    int		l;
<span class="lno">908  </span>#endif
</span><span class="nop"><span class="lno">909  </span>
</span><span class="del"><span class="lno">910  </span>    cpo_lit = vim_strchr(p_cpo, CPO_LITERAL) != NULL;
<span class="lno">911  </span>    cpo_bsl = vim_strchr(p_cpo, CPO_BACKSL) != NULL;
<span class="lno">912  </span>
</span><span class="nop"><span class="lno">913  </span>    if (*p == &#39;^&#39;)	/* Complement of range. */
<span class="lno">914  </span>	++p;
<span class="lno">915  </span>    if (*p == &#39;]&#39; || *p == &#39;-&#39;)
</span></td><td class="ttd"><span class="lin">Line 1194 to 1203</span><span class="nop"><span class="lno">1194 </span>skip_anyof(p)
<span class="lno">1195 </span>    char_u	*p;
<span class="lno">1196 </span>{
</span><span class="nop"><span class="lno"> </span>
<span class="lno"> </span>
</span><span class="nop"><span class="lno">1197 </span>#ifdef FEAT_MBYTE
<span class="lno">1198 </span>    int		l;
<span class="lno">1199 </span>#endif
</span><span class="nop"><span class="lno">1200 </span>
</span><span class="nop"><span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
</span><span class="nop"><span class="lno">1201 </span>    if (*p == &#39;^&#39;)	/* Complement of range. */
<span class="lno">1202 </span>	++p;
<span class="lno">1203 </span>    if (*p == &#39;]&#39; || *p == &#39;-&#39;)
</span></td></tr>
<tr><td class="ttd"><span class="lin">Line 928 to 936</span><span class="nop"><span class="lno">928  </span>		    mb_ptr_adv(p);
<span class="lno">929  </span>	    }
<span class="lno">930  </span>	else if (*p == &#39;\\&#39;
</span><span class="upd"><span class="lno">931  </span>		&amp;&amp; !cpo_bsl
</span><span class="nop"><span class="lno">932  </span>		&amp;&amp; (vim_strchr(REGEXP_INRANGE, p[1]) != NULL
</span><span class="upd"><span class="lno">933  </span>		    || (!cpo_lit &amp;&amp; vim_strchr(REGEXP_ABBR, p[1]) != NULL)))
</span><span class="nop"><span class="lno">934  </span>	    p += 2;
<span class="lno">935  </span>	else if (*p == &#39;[&#39;)
<span class="lno">936  </span>	{
</span></td><td class="ttd"><span class="lin">Line 1216 to 1224</span><span class="nop"><span class="lno">1216 </span>		    mb_ptr_adv(p);
<span class="lno">1217 </span>	    }
<span class="lno">1218 </span>	else if (*p == &#39;\\&#39;
</span><span class="upd"><span class="lno">1219 </span>		&amp;&amp; !<span class="chg">reg_</span>cpo_bsl
</span><span class="nop"><span class="lno">1220 </span>		&amp;&amp; (vim_strchr(REGEXP_INRANGE, p[1]) != NULL
</span><span class="upd"><span class="lno">1221 </span>		    || (!<span class="chg">reg_</span>cpo_lit &amp;&amp; vim_strchr(REGEXP_ABBR, p[1]) != NULL)))
</span><span class="nop"><span class="lno">1222 </span>	    p += 2;
<span class="lno">1223 </span>	else if (*p == &#39;[&#39;)
<span class="lno">1224 </span>	{
</span></td></tr>
<tr><td class="ttd"><span class="lin">Line 969 to 974</span><span class="nop"><span class="lno">969  </span>	mymagic = MAGIC_ON;
<span class="lno">970  </span>    else
<span class="lno">971  </span>	mymagic = MAGIC_OFF;
</span><span class="nop"><span class="lno"> </span>
</span><span class="nop"><span class="lno">972  </span>
<span class="lno">973  </span>    for (; p[0] != NUL; mb_ptr_adv(p))
<span class="lno">974  </span>    {
</span></td><td class="ttd"><span class="lin">Line 1257 to 1263</span><span class="nop"><span class="lno">1257 </span>	mymagic = MAGIC_ON;
<span class="lno">1258 </span>    else
<span class="lno">1259 </span>	mymagic = MAGIC_OFF;
</span><span class="add"><span class="lno">1260 </span>    get_cpo_flags();
</span><span class="nop"><span class="lno">1261 </span>
<span class="lno">1262 </span>    for (; p[0] != NUL; mb_ptr_adv(p))
<span class="lno">1263 </span>    {
</span></td></tr>
<tr><td class="ttd"><span class="lin">Line 1008 to 1015</span><span class="nop"><span class="lno">1008 </span>    return p;
<span class="lno">1009 </span>}
<span class="lno">1010 </span>
</span><span class="nop"><span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
</span><span class="nop"><span class="lno">1011 </span>/*
</span><span class="upd"><span class="lno">1012 </span> * <span class="chg">vim</span>_regcomp() - compile a regular expression into internal code
</span><span class="nop"><span class="lno"> </span>
</span><span class="nop"><span class="lno">1013 </span> * Returns the program in allocated space.  Returns NULL for an error.
<span class="lno">1014 </span> *
<span class="lno">1015 </span> * We can&#39;t allocate space until we know how big the compiled form will be,
</span></td><td class="ttd"><span class="lin">Line 1297 to 1308</span><span class="nop"><span class="lno">1297 </span>    return p;
<span class="lno">1298 </span>}
<span class="lno">1299 </span>
</span><span class="add"><span class="lno">1300 </span>static regprog_T  *bt_regcomp __ARGS((char_u *expr, int re_flags));
<span class="lno">1301 </span>static void bt_regfree __ARGS((regprog_T *prog));
<span class="lno">1302 </span>
</span><span class="nop"><span class="lno">1303 </span>/*
</span><span class="upd"><span class="lno">1304 </span> * <span class="chg">bt</span>_regcomp() - compile a regular expression into internal code<span class="chg"> for the</span>
</span><span class="add"><span class="lno">1305 </span> * traditional back track matcher.
</span><span class="nop"><span class="lno">1306 </span> * Returns the program in allocated space.  Returns NULL for an error.
<span class="lno">1307 </span> *
<span class="lno">1308 </span> * We can&#39;t allocate space until we know how big the compiled form will be,
</span></td></tr>
<tr><td class="ttd"><span class="lin">Line 1028 to 1039</span><span class="nop"><span class="lno">1028 </span> * of the structure of the compiled regexp.
<span class="lno">1029 </span> * &#34;re_flags&#34;: RE_MAGIC and/or RE_STRING.
<span class="lno">1030 </span> */
</span><span class="upd"><span class="lno">1031 </span>    regprog_T *
<span class="lno">1032 </span><span class="chg">vim</span>_regcomp(expr, re_flags)
</span><span class="nop"><span class="lno">1033 </span>    char_u	*expr;
<span class="lno">1034 </span>    int		re_flags;
<span class="lno">1035 </span>{
</span><span class="upd"><span class="lno">1036 </span>    regprog_T<span class="chg">	</span>*r;
</span><span class="nop"><span class="lno">1037 </span>    char_u	*scan;
<span class="lno">1038 </span>    char_u	*longest;
<span class="lno">1039 </span>    int		len;
</span></td><td class="ttd"><span class="lin">Line 1321 to 1332</span><span class="nop"><span class="lno">1321 </span> * of the structure of the compiled regexp.
<span class="lno">1322 </span> * &#34;re_flags&#34;: RE_MAGIC and/or RE_STRING.
<span class="lno">1323 </span> */
</span><span class="upd"><span class="lno">1324 </span>    <span class="chg">static </span>regprog_T *
<span class="lno">1325 </span><span class="chg">bt</span>_regcomp(expr, re_flags)
</span><span class="nop"><span class="lno">1326 </span>    char_u	*expr;
<span class="lno">1327 </span>    int		re_flags;
<span class="lno">1328 </span>{
</span><span class="upd"><span class="lno">1329 </span>    <span class="chg">bt_</span>regprog_T<span class="chg">    </span>*r;
</span><span class="nop"><span class="lno">1330 </span>    char_u	*scan;
<span class="lno">1331 </span>    char_u	*longest;
<span class="lno">1332 </span>    int		len;
</span></td></tr>
<tr><td class="ttd"><span class="lin">Line 1060 to 1066</span><span class="nop"><span class="lno">1060 </span>#endif
<span class="lno">1061 </span>
<span class="lno">1062 </span>    /* Allocate space. */
</span><span class="upd"><span class="lno">1063 </span>    r = (regprog_T *)lalloc(sizeof(regprog_T) + regsize, TRUE);
</span><span class="nop"><span class="lno">1064 </span>    if (r == NULL)
<span class="lno">1065 </span>	return NULL;
<span class="lno">1066 </span>
</span></td><td class="ttd"><span class="lin">Line 1353 to 1359</span><span class="nop"><span class="lno">1353 </span>#endif
<span class="lno">1354 </span>
<span class="lno">1355 </span>    /* Allocate space. */
</span><span class="upd"><span class="lno">1356 </span>    r = (<span class="chg">bt_</span>regprog_T *)lalloc(sizeof(<span class="chg">bt_</span>regprog_T) + regsize, TRUE);
</span><span class="nop"><span class="lno">1357 </span>    if (r == NULL)
<span class="lno">1358 </span>	return NULL;
<span class="lno">1359 </span>
</span></td></tr>
<tr><td class="ttd"><span class="lin">Line 1155 to 1164</span><span class="nop"><span class="lno">1155 </span>	    r-&gt;regmlen = len;
<span class="lno">1156 </span>	}
<span class="lno">1157 </span>    }
</span><span class="upd"><span class="lno">1158 </span>#ifdef D<span class="chg">EB</span>U<span class="chg">G</span>
</span><span class="nop"><span class="lno">1159 </span>    regdump(expr, r);
<span class="lno">1160 </span>#endif
</span><span class="upd"><span class="lno">1161 </span>    ret<span class="chg">u</span>rn<span class="chg"> r</span>;
</span><span class="nop"><span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
</span><span class="nop"><span class="lno">1162 </span>}
<span class="lno">1163 </span>
<span class="lno">1164 </span>/*
</span></td><td class="ttd"><span class="lin">Line 1448 to 1468</span><span class="nop"><span class="lno">1448 </span>	    r-&gt;regmlen = len;
<span class="lno">1449 </span>	}
<span class="lno">1450 </span>    }
</span><span class="upd"><span class="lno">1451 </span>#ifdef <span class="chg">BT_REGEXP_</span>DU<span class="chg">MP</span>
</span><span class="nop"><span class="lno">1452 </span>    regdump(expr, r);
<span class="lno">1453 </span>#endif
</span><span class="upd"><span class="lno">1454 </span>    r<span class="chg">-&gt;</span>e<span class="chg">ngine = &amp;b</span>t<span class="chg">_</span>r<span class="chg">ege</span>n<span class="chg">gine</span>;
</span><span class="add"><span class="lno">1455 </span>    return (regprog_T *)r;
<span class="lno">1456 </span>}
<span class="lno">1457 </span>
<span class="lno">1458 </span>/*
<span class="lno">1459 </span> * Free a compiled regexp program, returned by bt_regcomp().
<span class="lno">1460 </span> */
<span class="lno">1461 </span>    static void
<span class="lno">1462 </span>bt_regfree(prog)
<span class="lno">1463 </span>    regprog_T   *prog;
<span class="lno">1464 </span>{
<span class="lno">1465 </span>    vim_free(prog);
</span><span class="nop"><span class="lno">1466 </span>}
<span class="lno">1467 </span>
<span class="lno">1468 </span>/*
</span></td></tr>
<tr><td class="ttd"><span class="lin">Line 1176 to 1181</span><span class="nop"><span class="lno">1176 </span>	reg_magic = MAGIC_OFF;
<span class="lno">1177 </span>    reg_string = (re_flags &amp; RE_STRING);
<span class="lno">1178 </span>    reg_strict = (re_flags &amp; RE_STRICT);
</span><span class="nop"><span class="lno"> </span>
</span><span class="nop"><span class="lno">1179 </span>
<span class="lno">1180 </span>    num_complex_braces = 0;
<span class="lno">1181 </span>    regnpar = 1;
</span></td><td class="ttd"><span class="lin">Line 1480 to 1486</span><span class="nop"><span class="lno">1480 </span>	reg_magic = MAGIC_OFF;
<span class="lno">1481 </span>    reg_string = (re_flags &amp; RE_STRING);
<span class="lno">1482 </span>    reg_strict = (re_flags &amp; RE_STRICT);
</span><span class="add"><span class="lno">1483 </span>    get_cpo_flags();
</span><span class="nop"><span class="lno">1484 </span>
<span class="lno">1485 </span>    num_complex_braces = 0;
<span class="lno">1486 </span>    regnpar = 1;
</span></td></tr>
<tr><td class="ttd"><span class="lin">Line 1205 to 1211</span><span class="nop"><span class="lno">1205 </span>#endif
<span class="lno">1206 </span>
<span class="lno">1207 </span>/*
</span><span class="upd"><span class="lno">1208 </span> * re<span class="chg">g -</span> regular expression, i.e. main body or parenthesized thing
</span><span class="nop"><span class="lno">1209 </span> *
<span class="lno">1210 </span> * Caller must absorb opening parenthesis.
<span class="lno">1211 </span> *
</span></td><td class="ttd"><span class="lin">Line 1510 to 1516</span><span class="nop"><span class="lno">1510 </span>#endif
<span class="lno">1511 </span>
<span class="lno">1512 </span>/*
</span><span class="upd"><span class="lno">1513 </span> * <span class="chg">Pa</span>r<span class="chg">s</span>e regular expression, i.e. main body or parenthesized thing<span class="chg">.</span>
</span><span class="nop"><span class="lno">1514 </span> *
<span class="lno">1515 </span> * Caller must absorb opening parenthesis.
<span class="lno">1516 </span> *
</span></td></tr>
<tr><td class="ttd"><span class="lin">Line 1242 to 1248</span><span class="nop"><span class="lno">1242 </span>    {
<span class="lno">1243 </span>	/* Make a MOPEN node. */
<span class="lno">1244 </span>	if (regnpar &gt;= NSUBEXP)
</span><span class="upd"><span class="lno">1245 </span>	    EMSG<span class="chg">_M</span>_RET_NULL(_(&#34;E51: Too many %s(&#34;), reg_magic == MAGIC_ALL);
</span><span class="nop"><span class="lno">1246 </span>	parno = regnpar;
<span class="lno">1247 </span>	++regnpar;
<span class="lno">1248 </span>	ret = regnode(MOPEN + parno);
</span></td><td class="ttd"><span class="lin">Line 1547 to 1553</span><span class="nop"><span class="lno">1547 </span>    {
<span class="lno">1548 </span>	/* Make a MOPEN node. */
<span class="lno">1549 </span>	if (regnpar &gt;= NSUBEXP)
</span><span class="upd"><span class="lno">1550 </span>	    EMSG<span class="chg">2</span>_RET_NULL(_(&#34;E51: Too many %s(&#34;), reg_magic == MAGIC_ALL);
</span><span class="nop"><span class="lno">1551 </span>	parno = regnpar;
<span class="lno">1552 </span>	++regnpar;
<span class="lno">1553 </span>	ret = regnode(MOPEN + parno);
</span></td></tr>
<tr><td class="ttd"><span class="lin">Line 1303 to 1316</span><span class="nop"><span class="lno">1303 </span>	else
<span class="lno">1304 </span>#endif
<span class="lno">1305 </span>	    if (paren == REG_NPAREN)
</span><span class="upd"><span class="lno">1306 </span>	    EMSG<span class="chg">_M</span>_RET_NULL(_(<span class="chg">&#34;E53: U</span>nmatched<span class="chg"> %s%%(&#34;</span>), reg_magic == MAGIC_ALL);
</span><span class="nop"><span class="lno">1307 </span>	else
</span><span class="upd"><span class="lno">1308 </span>	    EMSG<span class="chg">_M</span>_RET_NULL(_(<span class="chg">&#34;E54: U</span>nmatched<span class="chg"> %s(&#34;</span>), reg_magic == MAGIC_ALL);
</span><span class="nop"><span class="lno">1309 </span>    }
<span class="lno">1310 </span>    else if (paren == REG_NOPAREN &amp;&amp; peekchr() != NUL)
<span class="lno">1311 </span>    {
</span><span class="nop"><span class="lno">1312 </span>	if (curchr == Magic(&#39;)&#39;))
</span><span class="upd"><span class="lno">1313 </span>	    EMSG<span class="chg">_M</span>_RET_NULL(_(<span class="chg">&#34;E55: U</span>nmatched<span class="chg"> %s)&#34;</span>), reg_magic == MAGIC_ALL);
</span><span class="nop"><span class="lno">1314 </span>	else
<span class="lno">1315 </span>	    EMSG_RET_NULL(_(e_trailing));	/* &#34;Can&#39;t happen&#34;. */
<span class="lno">1316 </span>	/* NOTREACHED */
</span></td><td class="ttd"><span class="lin">Line 1608 to 1621</span><span class="nop"><span class="lno">1608 </span>	else
<span class="lno">1609 </span>#endif
<span class="lno">1610 </span>	    if (paren == REG_NPAREN)
</span><span class="upd"><span class="lno">1611 </span>	    EMSG<span class="chg">2</span>_RET_NULL(_(<span class="chg">e_u</span>nmatched<span class="chg">pp</span>), reg_magic == MAGIC_ALL);
</span><span class="nop"><span class="lno">1612 </span>	else
</span><span class="upd"><span class="lno">1613 </span>	    EMSG<span class="chg">2</span>_RET_NULL(_(<span class="chg">e_u</span>nmatched<span class="chg">p</span>), reg_magic == MAGIC_ALL);
</span><span class="nop"><span class="lno">1614 </span>    }
<span class="lno">1615 </span>    else if (paren == REG_NOPAREN &amp;&amp; peekchr() != NUL)
<span class="lno">1616 </span>    {
</span><span class="nop"><span class="lno">1617 </span>	if (curchr == Magic(&#39;)&#39;))
</span><span class="upd"><span class="lno">1618 </span>	    EMSG<span class="chg">2</span>_RET_NULL(_(<span class="chg">e_u</span>nmatched<span class="chg">par</span>), reg_magic == MAGIC_ALL);
</span><span class="nop"><span class="lno">1619 </span>	else
<span class="lno">1620 </span>	    EMSG_RET_NULL(_(e_trailing));	/* &#34;Can&#39;t happen&#34;. */
<span class="lno">1621 </span>	/* NOTREACHED */
</span></td></tr>
<tr><td class="ttd"><span class="lin">Line 1325 to 1331</span><span class="nop"><span class="lno">1325 </span>}
<span class="lno">1326 </span>
<span class="lno">1327 </span>/*
</span><span class="upd"><span class="lno">1328 </span> * <span class="chg">H</span>a<span class="chg">ndl</span>e one alternative of an | operator.
</span><span class="nop"><span class="lno">1329 </span> * Implements the &amp; operator.
<span class="lno">1330 </span> */
<span class="lno">1331 </span>    static char_u *
</span></td><td class="ttd"><span class="lin">Line 1630 to 1636</span><span class="nop"><span class="lno">1630 </span>}
<span class="lno">1631 </span>
<span class="lno">1632 </span>/*
</span><span class="upd"><span class="lno">1633 </span> * <span class="chg">P</span>a<span class="chg">rs</span>e one alternative of an | operator.
</span><span class="nop"><span class="lno">1634 </span> * Implements the &amp; operator.
<span class="lno">1635 </span> */
<span class="lno">1636 </span>    static char_u *
</span></td></tr>
<tr><td class="ttd"><span class="lin">Line 1368 to 1374</span><span class="nop"><span class="lno">1368 </span>}
<span class="lno">1369 </span>
<span class="lno">1370 </span>/*
</span><span class="upd"><span class="lno">1371 </span> * <span class="chg">H</span>a<span class="chg">ndl</span>e one alternative of an | or &amp; operator.
</span><span class="nop"><span class="lno">1372 </span> * Implements the concatenation operator.
<span class="lno">1373 </span> */
<span class="lno">1374 </span>    static char_u *
</span></td><td class="ttd"><span class="lin">Line 1673 to 1679</span><span class="nop"><span class="lno">1673 </span>}
<span class="lno">1674 </span>
<span class="lno">1675 </span>/*
</span><span class="upd"><span class="lno">1676 </span> * <span class="chg">P</span>a<span class="chg">rs</span>e one alternative of an | or &amp; operator.
</span><span class="nop"><span class="lno">1677 </span> * Implements the concatenation operator.
<span class="lno">1678 </span> */
<span class="lno">1679 </span>    static char_u *
</span></td></tr>
<tr><td class="ttd"><span class="lin">Line 1448 to 1454</span><span class="nop"><span class="lno">1448 </span>}
<span class="lno">1449 </span>
<span class="lno">1450 </span>/*
</span><span class="upd"><span class="lno">1451 </span> * r<span class="chg">egpiec</span>e <span class="chg">- </span>something followed by possible [*+=]
</span><span class="nop"><span class="lno">1452 </span> *
<span class="lno">1453 </span> * Note that the branching code sequences used for = and the general cases
<span class="lno">1454 </span> * of * and + are somewhat optimized:  they use the same NOTHING node as
</span></td><td class="ttd"><span class="lin">Line 1753 to 1759</span><span class="nop"><span class="lno">1753 </span>}
<span class="lno">1754 </span>
<span class="lno">1755 </span>/*
</span><span class="upd"><span class="lno">1756 </span> * <span class="chg">Pa</span>r<span class="chg">s</span>e something followed by possible [*+=]<span class="chg">.</span>
</span><span class="nop"><span class="lno">1757 </span> *
<span class="lno">1758 </span> * Note that the branching code sequences used for = and the general cases
<span class="lno">1759 </span> * of * and + are somewhat optimized:  they use the same NOTHING node as
</span></td></tr>
<tr><td class="ttd"><span class="lin">Line 1515 to 1521</span><span class="nop"><span class="lno">1515 </span>	case Magic(&#39;@&#39;):
<span class="lno">1516 </span>	    {
<span class="lno">1517 </span>		int	lop = END;
</span><span class="nop"><span class="lno"> </span>
</span><span class="nop"><span class="lno">1518 </span>
</span><span class="nop"><span class="lno"> </span>
</span><span class="nop"><span class="lno">1519 </span>		switch (no_Magic(getchr()))
<span class="lno">1520 </span>		{
<span class="lno">1521 </span>		    case &#39;=&#39;: lop = MATCH; break;		  /* \@= */
</span></td><td class="ttd"><span class="lin">Line 1820 to 1828</span><span class="nop"><span class="lno">1820 </span>	case Magic(&#39;@&#39;):
<span class="lno">1821 </span>	    {
<span class="lno">1822 </span>		int	lop = END;
</span><span class="add"><span class="lno">1823 </span>		int	nr;
</span><span class="nop"><span class="lno">1824 </span>
</span><span class="add"><span class="lno">1825 </span>		nr = getdecchrs();
</span><span class="nop"><span class="lno">1826 </span>		switch (no_Magic(getchr()))
<span class="lno">1827 </span>		{
<span class="lno">1828 </span>		    case &#39;=&#39;: lop = MATCH; break;		  /* \@= */
</span></td></tr>
<tr><td class="ttd"><span class="lin">Line 1528 to 1534</span><span class="nop"><span class="lno">1528 </span>			      }
<span class="lno">1529 </span>		}
<span class="lno">1530 </span>		if (lop == END)
</span><span class="upd"><span class="lno">1531 </span>		    EMSG<span class="chg">_M</span>_RET_NULL(_(&#34;E59: invalid character after %s@&#34;),
</span><span class="nop"><span class="lno">1532 </span>						      reg_magic == MAGIC_ALL);
<span class="lno">1533 </span>		/* Look behind must match with behind_pos. */
<span class="lno">1534 </span>		if (lop == BEHIND || lop == NOBEHIND)
</span></td><td class="ttd"><span class="lin">Line 1835 to 1841</span><span class="nop"><span class="lno">1835 </span>			      }
<span class="lno">1836 </span>		}
<span class="lno">1837 </span>		if (lop == END)
</span><span class="upd"><span class="lno">1838 </span>		    EMSG<span class="chg">2</span>_RET_NULL(_(&#34;E59: invalid character after %s@&#34;),
</span><span class="nop"><span class="lno">1839 </span>						      reg_magic == MAGIC_ALL);
<span class="lno">1840 </span>		/* Look behind must match with behind_pos. */
<span class="lno">1841 </span>		if (lop == BEHIND || lop == NOBEHIND)
</span></td></tr>
<tr><td class="ttd"><span class="lin">Line 1537 to 1543</span><span class="nop"><span class="lno">1537 </span>		    *flagp |= HASLOOKBH;
<span class="lno">1538 </span>		}
<span class="lno">1539 </span>		regtail(ret, regnode(END)); /* operand ends */
</span><span class="upd"><span class="lno">1540 </span>		<span class="chg">reg</span>i<span class="chg">nsert</span>(lop<span class="chg">,</span> <span class="chg">ret</span>)<span class="chg">;</span>
</span><span class="nop"><span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
</span><span class="nop"><span class="lno">1541 </span>		break;
<span class="lno">1542 </span>	    }
<span class="lno">1543 </span>
</span></td><td class="ttd"><span class="lin">Line 1844 to 1857</span><span class="nop"><span class="lno">1844 </span>		    *flagp |= HASLOOKBH;
<span class="lno">1845 </span>		}
<span class="lno">1846 </span>		regtail(ret, regnode(END)); /* operand ends */
</span><span class="upd"><span class="lno">1847 </span>		i<span class="chg">f </span>(lop <span class="chg">== BEHIND || lop == NOBEHIND</span>)
</span><span class="add"><span class="lno">1848 </span>		{
<span class="lno">1849 </span>		    if (nr &lt; 0)
<span class="lno">1850 </span>			nr = 0; /* no limit is same as zero limit */
<span class="lno">1851 </span>		    reginsert_nr(lop, nr, ret);
<span class="lno">1852 </span>		}
<span class="lno">1853 </span>		else
<span class="lno">1854 </span>		    reginsert(lop, ret);
</span><span class="nop"><span class="lno">1855 </span>		break;
<span class="lno">1856 </span>	    }
<span class="lno">1857 </span>
</span></td></tr>
<tr><td class="ttd"><span class="lin">Line 1562 to 1568</span><span class="nop"><span class="lno">1562 </span>	    else
<span class="lno">1563 </span>	    {
<span class="lno">1564 </span>		if (num_complex_braces &gt;= 10)
</span><span class="upd"><span class="lno">1565 </span>		    EMSG<span class="chg">_M</span>_RET_NULL(_(&#34;E60: Too many complex %s{...}s&#34;),
</span><span class="nop"><span class="lno">1566 </span>						      reg_magic == MAGIC_ALL);
<span class="lno">1567 </span>		reginsert(BRACE_COMPLEX + num_complex_braces, ret);
<span class="lno">1568 </span>		regoptail(ret, regnode(BACK));
</span></td><td class="ttd"><span class="lin">Line 1876 to 1882</span><span class="nop"><span class="lno">1876 </span>	    else
<span class="lno">1877 </span>	    {
<span class="lno">1878 </span>		if (num_complex_braces &gt;= 10)
</span><span class="upd"><span class="lno">1879 </span>		    EMSG<span class="chg">2</span>_RET_NULL(_(&#34;E60: Too many complex %s{...}s&#34;),
</span><span class="nop"><span class="lno">1880 </span>						      reg_magic == MAGIC_ALL);
<span class="lno">1881 </span>		reginsert(BRACE_COMPLEX + num_complex_braces, ret);
<span class="lno">1882 </span>		regoptail(ret, regnode(BACK));
</span></td></tr>
<tr><td class="ttd"><span class="lin">Line 1588 to 1596</span><span class="nop"><span class="lno">1588 </span>
<span class="lno">1589 </span>    return ret;
<span class="lno">1590 </span>}
</span><span class="nop"><span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
</span><span class="nop"><span class="lno">1591 </span>
<span class="lno">1592 </span>/*
</span><span class="upd"><span class="lno">1593 </span> * re<span class="chg">gatom -</span> the lowest level
</span><span class="nop"><span class="lno">1594 </span> *
<span class="lno">1595 </span> * Optimization:  gobbles an entire sequence of ordinary characters so that
<span class="lno">1596 </span> * it can turn them into a single node, which is smaller to store and
</span></td><td class="ttd"><span class="lin">Line 1902 to 1922</span><span class="nop"><span class="lno">1902 </span>
<span class="lno">1903 </span>    return ret;
<span class="lno">1904 </span>}
</span><span class="add"><span class="lno">1905 </span>
<span class="lno">1906 </span>/* When making changes to classchars also change nfa_classcodes. */
<span class="lno">1907 </span>static char_u	*classchars = (char_u *)&#34;.iIkKfFpPsSdDxXoOwWhHaAlLuU&#34;;
<span class="lno">1908 </span>static int	classcodes[] = {
<span class="lno">1909 </span>    ANY, IDENT, SIDENT, KWORD, SKWORD,
<span class="lno">1910 </span>    FNAME, SFNAME, PRINT, SPRINT,
<span class="lno">1911 </span>    WHITE, NWHITE, DIGIT, NDIGIT,
<span class="lno">1912 </span>    HEX, NHEX, OCTAL, NOCTAL,
<span class="lno">1913 </span>    WORD, NWORD, HEAD, NHEAD,
<span class="lno">1914 </span>    ALPHA, NALPHA, LOWER, NLOWER,
<span class="lno">1915 </span>    UPPER, NUPPER
<span class="lno">1916 </span>};
</span><span class="nop"><span class="lno">1917 </span>
<span class="lno">1918 </span>/*
</span><span class="upd"><span class="lno">1919 </span> * <span class="chg">Pa</span>r<span class="chg">s</span>e the lowest level<span class="chg">.</span>
</span><span class="nop"><span class="lno">1920 </span> *
<span class="lno">1921 </span> * Optimization:  gobbles an entire sequence of ordinary characters so that
<span class="lno">1922 </span> * it can turn them into a single node, which is smaller to store and
</span></td></tr>
<tr><td class="ttd"><span class="lin">Line 1602 to 1625</span><span class="nop"><span class="lno">1602 </span>{
<span class="lno">1603 </span>    char_u	    *ret;
<span class="lno">1604 </span>    int		    flags;
</span><span class="del"><span class="lno">1605 </span>    int		    cpo_lit;	    /* &#39;cpoptions&#39; contains &#39;l&#39; flag */
<span class="lno">1606 </span>    int		    cpo_bsl;	    /* &#39;cpoptions&#39; contains &#39;\&#39; flag */
</span><span class="nop"><span class="lno">1607 </span>    int		    c;
</span><span class="del"><span class="lno">1608 </span>    static char_u   *classchars = (char_u *)&#34;.iIkKfFpPsSdDxXoOwWhHaAlLuU&#34;;
<span class="lno">1609 </span>    static int	    classcodes[] = {ANY, IDENT, SIDENT, KWORD, SKWORD,
<span class="lno">1610 </span>				    FNAME, SFNAME, PRINT, SPRINT,
<span class="lno">1611 </span>				    WHITE, NWHITE, DIGIT, NDIGIT,
<span class="lno">1612 </span>				    HEX, NHEX, OCTAL, NOCTAL,
<span class="lno">1613 </span>				    WORD, NWORD, HEAD, NHEAD,
<span class="lno">1614 </span>				    ALPHA, NALPHA, LOWER, NLOWER,
<span class="lno">1615 </span>				    UPPER, NUPPER
<span class="lno">1616 </span>				    };
</span><span class="nop"><span class="lno">1617 </span>    char_u	    *p;
<span class="lno">1618 </span>    int		    extra = 0;
<span class="lno">1619 </span>
</span><span class="nop"><span class="lno">1620 </span>    *flagp = WORST;		/* Tentatively. */
</span><span class="del"><span class="lno">1621 </span>    cpo_lit = vim_strchr(p_cpo, CPO_LITERAL) != NULL;
<span class="lno">1622 </span>    cpo_bsl = vim_strchr(p_cpo, CPO_BACKSL) != NULL;
</span><span class="nop"><span class="lno">1623 </span>
<span class="lno">1624 </span>    c = getchr();
<span class="lno">1625 </span>    switch (c)
</span></td><td class="ttd"><span class="lin">Line 1928 to 1938</span><span class="nop"><span class="lno">1928 </span>{
<span class="lno">1929 </span>    char_u	    *ret;
<span class="lno">1930 </span>    int		    flags;
</span><span class="nop"><span class="lno"> </span>
<span class="lno"> </span>
</span><span class="nop"><span class="lno">1931 </span>    int		    c;
</span><span class="nop"><span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
</span><span class="nop"><span class="lno">1932 </span>    char_u	    *p;
<span class="lno">1933 </span>    int		    extra = 0;
<span class="lno">1934 </span>
</span><span class="nop"><span class="lno">1935 </span>    *flagp = WORST;		/* Tentatively. */
</span><span class="nop"><span class="lno"> </span>
<span class="lno"> </span>
</span><span class="nop"><span class="lno">1936 </span>
<span class="lno">1937 </span>    c = getchr();
<span class="lno">1938 </span>    switch (c)
</span></td></tr>
<tr><td class="ttd"><span class="lin">Line 1826 to 1832</span><span class="nop"><span class="lno">1826 </span>	    {
<span class="lno">1827 </span>#ifdef FEAT_SYN_HL
<span class="lno">1828 </span>		case &#39;(&#39;: if (reg_do_extmatch != REX_SET)
</span><span class="upd"><span class="lno">1829 </span>			      EMSG_RET_NULL(_(<span class="chg">&#34;E66: \\</span>z<span class="chg">( </span>not<span class="chg"> </span>allowed<span class="chg"> here&#34;</span>));
</span><span class="nop"><span class="lno">1830 </span>			  if (one_exactly)
<span class="lno">1831 </span>			      EMSG_ONE_RET_NULL;
<span class="lno">1832 </span>			  ret = reg(REG_ZPAREN, &amp;flags);
</span></td><td class="ttd"><span class="lin">Line 2139 to 2145</span><span class="nop"><span class="lno">2139 </span>	    {
<span class="lno">2140 </span>#ifdef FEAT_SYN_HL
<span class="lno">2141 </span>		case &#39;(&#39;: if (reg_do_extmatch != REX_SET)
</span><span class="upd"><span class="lno">2142 </span>			      EMSG_RET_NULL(_(<span class="chg">e_</span>z<span class="chg">_</span>not<span class="chg">_</span>allowed));
</span><span class="nop"><span class="lno">2143 </span>			  if (one_exactly)
<span class="lno">2144 </span>			      EMSG_ONE_RET_NULL;
<span class="lno">2145 </span>			  ret = reg(REG_ZPAREN, &amp;flags);
</span></td></tr>
<tr><td class="ttd"><span class="lin">Line 1845 to 1851</span><span class="nop"><span class="lno">1845 </span>		case &#39;7&#39;:
<span class="lno">1846 </span>		case &#39;8&#39;:
<span class="lno">1847 </span>		case &#39;9&#39;: if (reg_do_extmatch != REX_USE)
</span><span class="upd"><span class="lno">1848 </span>			      EMSG_RET_NULL(_(<span class="chg">&#34;E67: \\</span>z1<span class="chg"> et al. </span>not<span class="chg"> </span>allowed<span class="chg"> here&#34;</span>));
</span><span class="nop"><span class="lno">1849 </span>			  ret = regnode(ZREF + c - &#39;0&#39;);
<span class="lno">1850 </span>			  re_has_z = REX_USE;
<span class="lno">1851 </span>			  break;
</span></td><td class="ttd"><span class="lin">Line 2158 to 2164</span><span class="nop"><span class="lno">2158 </span>		case &#39;7&#39;:
<span class="lno">2159 </span>		case &#39;8&#39;:
<span class="lno">2160 </span>		case &#39;9&#39;: if (reg_do_extmatch != REX_USE)
</span><span class="upd"><span class="lno">2161 </span>			      EMSG_RET_NULL(_(<span class="chg">e_</span>z1<span class="chg">_</span>not<span class="chg">_</span>allowed));
</span><span class="nop"><span class="lno">2162 </span>			  ret = regnode(ZREF + c - &#39;0&#39;);
<span class="lno">2163 </span>			  re_has_z = REX_USE;
<span class="lno">2164 </span>			  break;
</span></td></tr>
<tr><td class="ttd"><span class="lin">Line 1909 to 1915</span><span class="nop"><span class="lno">1909 </span>			      while ((c = getchr()) != &#39;]&#39;)
<span class="lno">1910 </span>			      {
<span class="lno">1911 </span>				  if (c == NUL)
</span><span class="upd"><span class="lno">1912 </span>				      EMSG<span class="chg">_M</span>_RET_NULL(_(<span class="chg">&#34;E69: M</span>issing<span class="chg"> ] after %</span>s<span class="chg">%%[&#34;</span>),
</span><span class="nop"><span class="lno">1913 </span>						      reg_magic == MAGIC_ALL);
<span class="lno">1914 </span>				  br = regnode(BRANCH);
<span class="lno">1915 </span>				  if (ret == NULL)
</span></td><td class="ttd"><span class="lin">Line 2222 to 2228</span><span class="nop"><span class="lno">2222 </span>			      while ((c = getchr()) != &#39;]&#39;)
<span class="lno">2223 </span>			      {
<span class="lno">2224 </span>				  if (c == NUL)
</span><span class="upd"><span class="lno">2225 </span>				      EMSG<span class="chg">2</span>_RET_NULL(_(<span class="chg">e_m</span>issing<span class="chg">_</span>s<span class="chg">b</span>),
</span><span class="nop"><span class="lno">2226 </span>						      reg_magic == MAGIC_ALL);
<span class="lno">2227 </span>				  br = regnode(BRANCH);
<span class="lno">2228 </span>				  if (ret == NULL)
</span></td></tr>
<tr><td class="ttd"><span class="lin">Line 1925 to 1931</span><span class="nop"><span class="lno">1925 </span>				      return NULL;
<span class="lno">1926 </span>			      }
<span class="lno">1927 </span>			      if (ret == NULL)
</span><span class="upd"><span class="lno">1928 </span>				  EMSG<span class="chg">_M</span>_RET_NULL(_(<span class="chg">&#34;E70: E</span>mpty<span class="chg"> %</span>s<span class="chg">%%[]&#34;</span>),
</span><span class="nop"><span class="lno">1929 </span>						      reg_magic == MAGIC_ALL);
<span class="lno">1930 </span>			      lastbranch = regnode(BRANCH);
<span class="lno">1931 </span>			      br = regnode(NOTHING);
</span></td><td class="ttd"><span class="lin">Line 2238 to 2244</span><span class="nop"><span class="lno">2238 </span>				      return NULL;
<span class="lno">2239 </span>			      }
<span class="lno">2240 </span>			      if (ret == NULL)
</span><span class="upd"><span class="lno">2241 </span>				  EMSG<span class="chg">2</span>_RET_NULL(_(<span class="chg">e_e</span>mpty<span class="chg">_</span>s<span class="chg">b</span>),
</span><span class="nop"><span class="lno">2242 </span>						      reg_magic == MAGIC_ALL);
<span class="lno">2243 </span>			      lastbranch = regnode(BRANCH);
<span class="lno">2244 </span>			      br = regnode(NOTHING);
</span></td></tr>
<tr><td class="ttd"><span class="lin">Line 1969 to 1975</span><span class="nop"><span class="lno">1969 </span>			      }
<span class="lno">1970 </span>
<span class="lno">1971 </span>			      if (i &lt; 0)
</span><span class="upd"><span class="lno">1972 </span>				  EMSG<span class="chg">_M</span>_RET_NULL(
</span><span class="nop"><span class="lno">1973 </span>					_(&#34;E678: Invalid character after %s%%[dxouU]&#34;),
<span class="lno">1974 </span>					reg_magic == MAGIC_ALL);
<span class="lno">1975 </span>#ifdef FEAT_MBYTE
</span></td><td class="ttd"><span class="lin">Line 2282 to 2288</span><span class="nop"><span class="lno">2282 </span>			      }
<span class="lno">2283 </span>
<span class="lno">2284 </span>			      if (i &lt; 0)
</span><span class="upd"><span class="lno">2285 </span>				  EMSG<span class="chg">2</span>_RET_NULL(
</span><span class="nop"><span class="lno">2286 </span>					_(&#34;E678: Invalid character after %s%%[dxouU]&#34;),
<span class="lno">2287 </span>					reg_magic == MAGIC_ALL);
<span class="lno">2288 </span>#ifdef FEAT_MBYTE
</span></td></tr>
<tr><td class="ttd"><span class="lin">Line 2041 to 2047</span><span class="nop"><span class="lno">2041 </span>			      }
<span class="lno">2042 </span>			  }
<span class="lno">2043 </span>
</span><span class="upd"><span class="lno">2044 </span>			  EMSG<span class="chg">_M</span>_RET_NULL(_(&#34;E71: Invalid character after %s%%&#34;),
</span><span class="nop"><span class="lno">2045 </span>						      reg_magic == MAGIC_ALL);
<span class="lno">2046 </span>	    }
<span class="lno">2047 </span>	}
</span></td><td class="ttd"><span class="lin">Line 2354 to 2360</span><span class="nop"><span class="lno">2354 </span>			      }
<span class="lno">2355 </span>			  }
<span class="lno">2356 </span>
</span><span class="upd"><span class="lno">2357 </span>			  EMSG<span class="chg">2</span>_RET_NULL(_(&#34;E71: Invalid character after %s%%&#34;),
</span><span class="nop"><span class="lno">2358 </span>						      reg_magic == MAGIC_ALL);
<span class="lno">2359 </span>	    }
<span class="lno">2360 </span>	}
</span></td></tr>
<tr><td class="ttd"><span class="lin">Line 2112 to 2118</span><span class="nop"><span class="lno">2112 </span>			    }
<span class="lno">2113 </span>
<span class="lno">2114 </span>			    /* Handle \o40, \x20 and \u20AC style sequences */
</span><span class="upd"><span class="lno">2115 </span>			    if (endc == &#39;\\&#39; &amp;&amp; !cpo_lit &amp;&amp; !cpo_bsl)
</span><span class="nop"><span class="lno">2116 </span>				endc = coll_get_char();
<span class="lno">2117 </span>
<span class="lno">2118 </span>			    if (startc &gt; endc)
</span></td><td class="ttd"><span class="lin">Line 2425 to 2431</span><span class="nop"><span class="lno">2425 </span>			    }
<span class="lno">2426 </span>
<span class="lno">2427 </span>			    /* Handle \o40, \x20 and \u20AC style sequences */
</span><span class="upd"><span class="lno">2428 </span>			    if (endc == &#39;\\&#39; &amp;&amp; !<span class="chg">reg_</span>cpo_lit &amp;&amp; !<span class="chg">reg_</span>cpo_bsl)
</span><span class="nop"><span class="lno">2429 </span>				endc = coll_get_char();
<span class="lno">2430 </span>
<span class="lno">2431 </span>			    if (startc &gt; endc)
</span></td></tr>
<tr><td class="ttd"><span class="lin">Line 2154 to 2162</span><span class="nop"><span class="lno">2154 </span>		     * Posix doesn&#39;t recognize backslash at all.
<span class="lno">2155 </span>		     */
<span class="lno">2156 </span>		    else if (*regparse == &#39;\\&#39;
</span><span class="upd"><span class="lno">2157 </span>			    &amp;&amp; !cpo_bsl
</span><span class="nop"><span class="lno">2158 </span>			    &amp;&amp; (vim_strchr(REGEXP_INRANGE, regparse[1]) != NULL
</span><span class="upd"><span class="lno">2159 </span>				|| (!cpo_lit
</span><span class="nop"><span class="lno">2160 </span>				    &amp;&amp; vim_strchr(REGEXP_ABBR,
<span class="lno">2161 </span>						       regparse[1]) != NULL)))
<span class="lno">2162 </span>		    {
</span></td><td class="ttd"><span class="lin">Line 2467 to 2475</span><span class="nop"><span class="lno">2467 </span>		     * Posix doesn&#39;t recognize backslash at all.
<span class="lno">2468 </span>		     */
<span class="lno">2469 </span>		    else if (*regparse == &#39;\\&#39;
</span><span class="upd"><span class="lno">2470 </span>			    &amp;&amp; !<span class="chg">reg_</span>cpo_bsl
</span><span class="nop"><span class="lno">2471 </span>			    &amp;&amp; (vim_strchr(REGEXP_INRANGE, regparse[1]) != NULL
</span><span class="upd"><span class="lno">2472 </span>				|| (!<span class="chg">reg_</span>cpo_lit
</span><span class="nop"><span class="lno">2473 </span>				    &amp;&amp; vim_strchr(REGEXP_ABBR,
<span class="lno">2474 </span>						       regparse[1]) != NULL)))
<span class="lno">2475 </span>		    {
</span></td></tr>
<tr><td class="ttd"><span class="lin">Line 2166 to 2178</span><span class="nop"><span class="lno">2166 </span>			    /* &#39;\n&#39; in range: also match NL */
<span class="lno">2167 </span>			    if (ret != JUST_CALC_SIZE)
<span class="lno">2168 </span>			    {
</span><span class="upd"><span class="lno">2169 </span>				i<span class="chg">f</span> <span class="chg">(*r</span>et <span class="chg">==</span> <span class="chg">ANYBUT)</span>
<span class="lno">2170 </span>				    <span class="chg">*r</span>e<span class="chg">t</span> <span class="chg">=</span> <span class="chg">ANYBUT</span> <span class="chg">+</span> <span class="chg">ADD_NL;</span>
<span class="lno">2171 </span>				<span class="chg">else </span>if (*ret == ANYOF)
</span><span class="nop"><span class="lno"> </span>
</span><span class="nop"><span class="lno">2172 </span>				    *ret = ANYOF + ADD_NL;
</span><span class="nop"><span class="lno"> </span>
<span class="lno"> </span>
</span><span class="nop"><span class="lno">2173 </span>				/* else: must have had a \n already */
<span class="lno">2174 </span>			    }
</span><span class="del"><span class="lno">2175 </span>			    *flagp |= HASNL;
</span><span class="nop"><span class="lno">2176 </span>			    regparse++;
<span class="lno">2177 </span>			    startc = -1;
<span class="lno">2178 </span>			}
</span></td><td class="ttd"><span class="lin">Line 2479 to 2493</span><span class="nop"><span class="lno">2479 </span>			    /* &#39;\n&#39; in range: also match NL */
<span class="lno">2480 </span>			    if (ret != JUST_CALC_SIZE)
<span class="lno">2481 </span>			    {
</span><span class="upd"><span class="lno">2482 </span>				<span class="chg">/* Us</span>i<span class="chg">ng \n inside [^]</span> <span class="chg">do</span>e<span class="chg">s no</span>t <span class="chg">change</span> <span class="chg">what</span>
<span class="lno">2483 </span>				 <span class="chg">*</span> <span class="chg">matches. &#34;[^\n]&#34;</span> <span class="chg">is</span> <span class="chg">th</span>e <span class="chg">same</span> <span class="chg">as</span> <span class="chg">&#34;.&#34;.</span> <span class="chg">*/</span>
<span class="lno">2484 </span>				if (*ret == ANYOF)
</span><span class="add"><span class="lno">2485 </span>				{
</span><span class="nop"><span class="lno">2486 </span>				    *ret = ANYOF + ADD_NL;
</span><span class="add"><span class="lno">2487 </span>				    *flagp |= HASNL;
<span class="lno">2488 </span>				}
</span><span class="nop"><span class="lno">2489 </span>				/* else: must have had a \n already */
<span class="lno">2490 </span>			    }
</span><span class="nop"><span class="lno"> </span>
</span><span class="nop"><span class="lno">2491 </span>			    regparse++;
<span class="lno">2492 </span>			    startc = -1;
<span class="lno">2493 </span>			}
</span></td></tr>
<tr><td class="ttd"><span class="lin">Line 2334 to 2341</span><span class="nop"><span class="lno">2334 </span>		break;
<span class="lno">2335 </span>	    }
<span class="lno">2336 </span>	    else if (reg_strict)
</span><span class="upd"><span class="lno">2337 </span>		EMSG<span class="chg">_M</span>_RET_NULL(_(<span class="chg">&#34;E769: M</span>issing<span class="chg"> ] </span>a<span class="chg">f</span>te<span class="chg">r</span> <span class="chg">%s[&#34;</span>)<span class="chg">,</span>
</span><span class="del"><span class="lno">2338 </span>						       reg_magic &gt; MAGIC_OFF);
</span><span class="nop"><span class="lno">2339 </span>	}
<span class="lno">2340 </span>	/* FALLTHROUGH */
<span class="lno">2341 </span>
</span></td><td class="ttd"><span class="lin">Line 2649 to 2655</span><span class="nop"><span class="lno">2649 </span>		break;
<span class="lno">2650 </span>	    }
<span class="lno">2651 </span>	    else if (reg_strict)
</span><span class="upd"><span class="lno">2652 </span>		EMSG<span class="chg">2</span>_RET_NULL(_(<span class="chg">e_m</span>issing<span class="chg">br</span>a<span class="chg">cke</span>t<span class="chg">), r</span>e<span class="chg">g_magic &gt;</span> <span class="chg">MAGIC_OFF</span>)<span class="chg">;</span>
</span><span class="nop"><span class="lno"> </span>
</span><span class="nop"><span class="lno">2653 </span>	}
<span class="lno">2654 </span>	/* FALLTHROUGH */
<span class="lno">2655 </span>
</span></td></tr>
<tr><td class="ttd"><span class="lin">Line 2426 to 2432</span><span class="nop"><span class="lno">2426 </span>#endif
<span class="lno">2427 </span>
<span class="lno">2428 </span>/*
</span><span class="upd"><span class="lno">2429 </span> * <span class="chg">e</span>mit a node
</span><span class="nop"><span class="lno">2430 </span> * Return pointer to generated code.
<span class="lno">2431 </span> */
<span class="lno">2432 </span>    static char_u *
</span></td><td class="ttd"><span class="lin">Line 2740 to 2746</span><span class="nop"><span class="lno">2740 </span>#endif
<span class="lno">2741 </span>
<span class="lno">2742 </span>/*
</span><span class="upd"><span class="lno">2743 </span> * <span class="chg">E</span>mit a node<span class="chg">.</span>
</span><span class="nop"><span class="lno">2744 </span> * Return pointer to generated code.
<span class="lno">2745 </span> */
<span class="lno">2746 </span>    static char_u *
</span></td></tr>
<tr><td class="ttd"><span class="lin">Line 2468 to 2473</span><span class="nop"><span class="lno">2468 </span>regmbc(c)
<span class="lno">2469 </span>    int		c;
<span class="lno">2470 </span>{
</span><span class="nop"><span class="lno"> </span>
<span class="lno"> </span>
</span><span class="nop"><span class="lno">2471 </span>    if (regcode == JUST_CALC_SIZE)
<span class="lno">2472 </span>	regsize += (*mb_char2len)(c);
<span class="lno">2473 </span>    else
</span></td><td class="ttd"><span class="lin">Line 2782 to 2789</span><span class="nop"><span class="lno">2782 </span>regmbc(c)
<span class="lno">2783 </span>    int		c;
<span class="lno">2784 </span>{
</span><span class="add"><span class="lno">2785 </span>    if (!has_mbyte &amp;&amp; c &gt; 0xff)
<span class="lno">2786 </span>	return;
</span><span class="nop"><span class="lno">2787 </span>    if (regcode == JUST_CALC_SIZE)
<span class="lno">2788 </span>	regsize += (*mb_char2len)(c);
<span class="lno">2789 </span>    else
</span></td></tr>
<tr><td class="ttd"><span class="lin">Line 2476 to 2482</span><span class="nop"><span class="lno">2476 </span>#endif
<span class="lno">2477 </span>
<span class="lno">2478 </span>/*
</span><span class="upd"><span class="lno">2479 </span> * <span class="chg">reginsert - i</span>nsert an operator in front of already-emitted operand
</span><span class="nop"><span class="lno">2480 </span> *
<span class="lno">2481 </span> * Means relocating the operand.
<span class="lno">2482 </span> */
</span></td><td class="ttd"><span class="lin">Line 2792 to 2798</span><span class="nop"><span class="lno">2792 </span>#endif
<span class="lno">2793 </span>
<span class="lno">2794 </span>/*
</span><span class="upd"><span class="lno">2795 </span> * <span class="chg">I</span>nsert an operator in front of already-emitted operand
</span><span class="nop"><span class="lno">2796 </span> *
<span class="lno">2797 </span> * Means relocating the operand.
<span class="lno">2798 </span> */
</span></td></tr>
<tr><td class="ttd"><span class="lin">Line 2507 to 2513</span><span class="nop"><span class="lno">2507 </span>}
<span class="lno">2508 </span>
<span class="lno">2509 </span>/*
</span><span class="upd"><span class="lno">2510 </span> * <span class="chg">reginsert_limits - i</span>nsert an operator in front of already-emitted operand.
</span><span class="nop"><span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
</span><span class="nop"><span class="lno">2511 </span> * The operator has the given limit values as operands.  Also set next pointer.
<span class="lno">2512 </span> *
<span class="lno">2513 </span> * Means relocating the operand.
</span></td><td class="ttd"><span class="lin">Line 2823 to 2861</span><span class="nop"><span class="lno">2823 </span>}
<span class="lno">2824 </span>
<span class="lno">2825 </span>/*
</span><span class="upd"><span class="lno">2826 </span> * <span class="chg">I</span>nsert an operator in front of already-emitted operand.
</span><span class="add"><span class="lno">2827 </span> * Add a number to the operator.
<span class="lno">2828 </span> */
<span class="lno">2829 </span>    static void
<span class="lno">2830 </span>reginsert_nr(op, val, opnd)
<span class="lno">2831 </span>    int		op;
<span class="lno">2832 </span>    long	val;
<span class="lno">2833 </span>    char_u	*opnd;
<span class="lno">2834 </span>{
<span class="lno">2835 </span>    char_u	*src;
<span class="lno">2836 </span>    char_u	*dst;
<span class="lno">2837 </span>    char_u	*place;
<span class="lno">2838 </span>
<span class="lno">2839 </span>    if (regcode == JUST_CALC_SIZE)
<span class="lno">2840 </span>    {
<span class="lno">2841 </span>	regsize += 7;
<span class="lno">2842 </span>	return;
<span class="lno">2843 </span>    }
<span class="lno">2844 </span>    src = regcode;
<span class="lno">2845 </span>    regcode += 7;
<span class="lno">2846 </span>    dst = regcode;
<span class="lno">2847 </span>    while (src &gt; opnd)
<span class="lno">2848 </span>	*--dst = *--src;
<span class="lno">2849 </span>
<span class="lno">2850 </span>    place = opnd;		/* Op node, where operand used to be. */
<span class="lno">2851 </span>    *place++ = op;
<span class="lno">2852 </span>    *place++ = NUL;
<span class="lno">2853 </span>    *place++ = NUL;
<span class="lno">2854 </span>    place = re_put_long(place, (long_u)val);
<span class="lno">2855 </span>}
<span class="lno">2856 </span>
<span class="lno">2857 </span>/*
<span class="lno">2858 </span> * Insert an operator in front of already-emitted operand.
</span><span class="nop"><span class="lno">2859 </span> * The operator has the given limit values as operands.  Also set next pointer.
<span class="lno">2860 </span> *
<span class="lno">2861 </span> * Means relocating the operand.
</span></td></tr>
<tr><td class="ttd"><span class="lin">Line 2559 to 2565</span><span class="nop"><span class="lno">2559 </span>}
<span class="lno">2560 </span>
<span class="lno">2561 </span>/*
</span><span class="upd"><span class="lno">2562 </span> * <span class="chg">regtail - s</span>et the next-pointer at the end of a node chain
</span><span class="nop"><span class="lno">2563 </span> */
<span class="lno">2564 </span>    static void
<span class="lno">2565 </span>regtail(p, val)
</span></td><td class="ttd"><span class="lin">Line 2907 to 2913</span><span class="nop"><span class="lno">2907 </span>}
<span class="lno">2908 </span>
<span class="lno">2909 </span>/*
</span><span class="upd"><span class="lno">2910 </span> * <span class="chg">S</span>et the next-pointer at the end of a node chain<span class="chg">.</span>
</span><span class="nop"><span class="lno">2911 </span> */
<span class="lno">2912 </span>    static void
<span class="lno">2913 </span>regtail(p, val)
</span></td></tr>
<tr><td class="ttd"><span class="lin">Line 2588 to 2594</span><span class="nop"><span class="lno">2588 </span>    else
<span class="lno">2589 </span>	offset = (int)(val - scan);
<span class="lno">2590 </span>    /* When the offset uses more than 16 bits it can no longer fit in the two
</span><span class="upd"><span class="lno">2591 </span>     * bytes aval<span class="chg">i</span>able.  Use a global flag to avoid having to check return
</span><span class="nop"><span class="lno">2592 </span>     * values in too many places. */
<span class="lno">2593 </span>    if (offset &gt; 0xffff)
<span class="lno">2594 </span>	reg_toolong = TRUE;
</span></td><td class="ttd"><span class="lin">Line 2936 to 2942</span><span class="nop"><span class="lno">2936 </span>    else
<span class="lno">2937 </span>	offset = (int)(val - scan);
<span class="lno">2938 </span>    /* When the offset uses more than 16 bits it can no longer fit in the two
</span><span class="upd"><span class="lno">2939 </span>     * bytes ava<span class="chg">i</span>lable.  Use a global flag to avoid having to check return
</span><span class="nop"><span class="lno">2940 </span>     * values in too many places. */
<span class="lno">2941 </span>    if (offset &gt; 0xffff)
<span class="lno">2942 </span>	reg_toolong = TRUE;
</span></td></tr>
<tr><td class="ttd"><span class="lin">Line 2600 to 2606</span><span class="nop"><span class="lno">2600 </span>}
<span class="lno">2601 </span>
<span class="lno">2602 </span>/*
</span><span class="upd"><span class="lno">2603 </span> * <span class="chg">r</span>e<span class="chg">goptail -</span> regtail on item after a BRANCH; nop if none
</span><span class="nop"><span class="lno">2604 </span> */
<span class="lno">2605 </span>    static void
<span class="lno">2606 </span>regoptail(p, val)
</span></td><td class="ttd"><span class="lin">Line 2948 to 2954</span><span class="nop"><span class="lno">2948 </span>}
<span class="lno">2949 </span>
<span class="lno">2950 </span>/*
</span><span class="upd"><span class="lno">2951 </span> * <span class="chg">Lik</span>e regtail<span class="chg">,</span> on item after a BRANCH; nop if none<span class="chg">.</span>
</span><span class="nop"><span class="lno">2952 </span> */
<span class="lno">2953 </span>    static void
<span class="lno">2954 </span>regoptail(p, val)
</span></td></tr>
<tr><td class="ttd"><span class="lin">Line 2616 to 2637</span><span class="nop"><span class="lno">2616 </span>}
<span class="lno">2617 </span>
<span class="lno">2618 </span>/*
</span><span class="upd"><span class="lno">2619 </span> * <span class="chg">ge</span>t<span class="chg">ch</span>r<span class="chg">() -</span> get<span class="chg"> </span>t<span class="chg">he </span>n<span class="chg">ext</span> character from the <span class="chg">patt</span>e<span class="chg">rn. W</span>e <span class="chg">k</span>n<span class="chg">ow abo</span>ut
</span><span class="del"><span class="lno">2620 </span> * magic and such, so therefore we need a lexical analyzer.
</span><span class="nop"><span class="lno">2621 </span> */
<span class="lno">2622 </span>
</span><span class="del"><span class="lno">2623 </span>/* static int	    curchr; */
<span class="lno">2624 </span>static int	prevprevchr;
<span class="lno">2625 </span>static int	prevchr;
<span class="lno">2626 </span>static int	nextchr;    /* used for ungetchr() */
<span class="lno">2627 </span>/*
<span class="lno">2628 </span> * Note: prevchr is sometimes -1 when we are not at the start,
<span class="lno">2629 </span> * eg in /[ ^I]^ the pattern was never found even if it existed, because ^ was
<span class="lno">2630 </span> * taken to be magic -- webb
<span class="lno">2631 </span> */
</span><span class="nop"><span class="lno">2632 </span>static int	at_start;	/* True when on the first character */
<span class="lno">2633 </span>static int	prev_at_start;  /* True when on the second character */
<span class="lno">2634 </span>
</span><span class="nop"><span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
</span><span class="nop"><span class="lno">2635 </span>    static void
<span class="lno">2636 </span>initchr(str)
<span class="lno">2637 </span>    char_u *str;
</span></td><td class="ttd"><span class="lin">Line 2964 to 2978</span><span class="nop"><span class="lno">2964 </span>}
<span class="lno">2965 </span>
<span class="lno">2966 </span>/*
</span><span class="upd"><span class="lno">2967 </span> * <span class="chg">Func</span>t<span class="chg">ions fo</span>r gett<span class="chg">i</span>n<span class="chg">g</span> character<span class="chg">s</span> from the <span class="chg">r</span>e<span class="chg">g</span>e<span class="chg">xp</span> <span class="chg">i</span>n<span class="chg">p</span>ut<span class="chg">.</span>
</span><span class="nop"><span class="lno"> </span>
</span><span class="nop"><span class="lno">2968 </span> */
<span class="lno">2969 </span>
</span><span class="nop"><span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
</span><span class="nop"><span class="lno">2970 </span>static int	at_start;	/* True when on the first character */
<span class="lno">2971 </span>static int	prev_at_start;  /* True when on the second character */
<span class="lno">2972 </span>
</span><span class="add"><span class="lno">2973 </span>/*
<span class="lno">2974 </span> * Start parsing at &#34;str&#34;.
<span class="lno">2975 </span> */
</span><span class="nop"><span class="lno">2976 </span>    static void
<span class="lno">2977 </span>initchr(str)
<span class="lno">2978 </span>    char_u *str;
</span></td></tr>
<tr><td class="ttd"><span class="lin">Line 2643 to 2648</span><span class="nop"><span class="lno">2643 </span>    prev_at_start = FALSE;
<span class="lno">2644 </span>}
<span class="lno">2645 </span>
</span><span class="nop"><span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
</span><span class="nop"><span class="lno">2646 </span>    static int
<span class="lno">2647 </span>peekchr()
<span class="lno">2648 </span>{
</span></td><td class="ttd"><span class="lin">Line 2984 to 3030</span><span class="nop"><span class="lno">2984 </span>    prev_at_start = FALSE;
<span class="lno">2985 </span>}
<span class="lno">2986 </span>
</span><span class="add"><span class="lno">2987 </span>/*
<span class="lno">2988 </span> * Save the current parse state, so that it can be restored and parsing
<span class="lno">2989 </span> * starts in the same state again.
<span class="lno">2990 </span> */
<span class="lno">2991 </span>    static void
<span class="lno">2992 </span>save_parse_state(ps)
<span class="lno">2993 </span>    parse_state_T *ps;
<span class="lno">2994 </span>{
<span class="lno">2995 </span>    ps-&gt;regparse = regparse;
<span class="lno">2996 </span>    ps-&gt;prevchr_len = prevchr_len;
<span class="lno">2997 </span>    ps-&gt;curchr = curchr;
<span class="lno">2998 </span>    ps-&gt;prevchr = prevchr;
<span class="lno">2999 </span>    ps-&gt;prevprevchr = prevprevchr;
<span class="lno">3000 </span>    ps-&gt;nextchr = nextchr;
<span class="lno">3001 </span>    ps-&gt;at_start = at_start;
<span class="lno">3002 </span>    ps-&gt;prev_at_start = prev_at_start;
<span class="lno">3003 </span>    ps-&gt;regnpar = regnpar;
<span class="lno">3004 </span>}
<span class="lno">3005 </span>
<span class="lno">3006 </span>/*
<span class="lno">3007 </span> * Restore a previously saved parse state.
<span class="lno">3008 </span> */
<span class="lno">3009 </span>    static void
<span class="lno">3010 </span>restore_parse_state(ps)
<span class="lno">3011 </span>    parse_state_T *ps;
<span class="lno">3012 </span>{
<span class="lno">3013 </span>    regparse = ps-&gt;regparse;
<span class="lno">3014 </span>    prevchr_len = ps-&gt;prevchr_len;
<span class="lno">3015 </span>    curchr = ps-&gt;curchr;
<span class="lno">3016 </span>    prevchr = ps-&gt;prevchr;
<span class="lno">3017 </span>    prevprevchr = ps-&gt;prevprevchr;
<span class="lno">3018 </span>    nextchr = ps-&gt;nextchr;
<span class="lno">3019 </span>    at_start = ps-&gt;at_start;
<span class="lno">3020 </span>    prev_at_start = ps-&gt;prev_at_start;
<span class="lno">3021 </span>    regnpar = ps-&gt;regnpar;
<span class="lno">3022 </span>}
<span class="lno">3023 </span>
<span class="lno">3024 </span>
<span class="lno">3025 </span>/*
<span class="lno">3026 </span> * Get the next character without advancing.
<span class="lno">3027 </span> */
</span><span class="nop"><span class="lno">3028 </span>    static int
<span class="lno">3029 </span>peekchr()
<span class="lno">3030 </span>{
</span></td></tr>
<tr><td class="ttd"><span class="lin">Line 2851 to 2856</span><span class="nop"><span class="lno">2851 </span>    prevprevchr = prpr;
<span class="lno">2852 </span>}
<span class="lno">2853 </span>
</span><span class="nop"><span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
</span><span class="nop"><span class="lno">2854 </span>    static int
<span class="lno">2855 </span>getchr()
<span class="lno">2856 </span>{
</span></td><td class="ttd"><span class="lin">Line 3233 to 3242</span><span class="nop"><span class="lno">3233 </span>    prevprevchr = prpr;
<span class="lno">3234 </span>}
<span class="lno">3235 </span>
</span><span class="add"><span class="lno">3236 </span>/*
<span class="lno">3237 </span> * Get the next character from the pattern. We know about magic and such, so
<span class="lno">3238 </span> * therefore we need a lexical analyzer.
<span class="lno">3239 </span> */
</span><span class="nop"><span class="lno">3240 </span>    static int
<span class="lno">3241 </span>getchr()
<span class="lno">3242 </span>{
</span></td></tr>
<tr><td class="ttd"><span class="lin">Line 2910 to 2916</span><span class="nop"><span class="lno">2910 </span>}
<span class="lno">2911 </span>
<span class="lno">2912 </span>/*
</span><span class="upd"><span class="lno">2913 </span> * <span class="chg">g</span>et and return the value of the decimal string immediately after the
</span><span class="nop"><span class="lno">2914 </span> * current position. Return -1 for invalid.  Consumes all digits.
<span class="lno">2915 </span> */
<span class="lno">2916 </span>    static int
</span></td><td class="ttd"><span class="lin">Line 3296 to 3302</span><span class="nop"><span class="lno">3296 </span>}
<span class="lno">3297 </span>
<span class="lno">3298 </span>/*
</span><span class="upd"><span class="lno">3299 </span> * <span class="chg">G</span>et and return the value of the decimal string immediately after the
</span><span class="nop"><span class="lno">3300 </span> * current position. Return -1 for invalid.  Consumes all digits.
<span class="lno">3301 </span> */
<span class="lno">3302 </span>    static int
</span></td></tr>
<tr><td class="ttd"><span class="lin">Line 2928 to 2933</span><span class="nop"><span class="lno">2928 </span>	nr *= 10;
<span class="lno">2929 </span>	nr += c - &#39;0&#39;;
<span class="lno">2930 </span>	++regparse;
</span><span class="nop"><span class="lno"> </span>
</span><span class="nop"><span class="lno">2931 </span>    }
<span class="lno">2932 </span>
<span class="lno">2933 </span>    if (i == 0)
</span></td><td class="ttd"><span class="lin">Line 3314 to 3320</span><span class="nop"><span class="lno">3314 </span>	nr *= 10;
<span class="lno">3315 </span>	nr += c - &#39;0&#39;;
<span class="lno">3316 </span>	++regparse;
</span><span class="add"><span class="lno">3317 </span>	curchr = -1; /* no longer valid */
</span><span class="nop"><span class="lno">3318 </span>    }
<span class="lno">3319 </span>
<span class="lno">3320 </span>    if (i == 0)
</span></td></tr>
<tr><td class="ttd"><span class="lin">Line 3105 to 3112</span><span class="nop"><span class="lno">3105 </span>} regbehind_T;
<span class="lno">3106 </span>
<span class="lno">3107 </span>static char_u	*reg_getline __ARGS((linenr_T lnum));
</span><span class="upd"><span class="lno">3108 </span>static long	<span class="chg">vim</span>_regexec_both __ARGS((char_u *line, colnr_T col, proftime_T *tm));
<span class="lno">3109 </span>static long	regtry __ARGS((regprog_T *prog, colnr_T col));
</span><span class="nop"><span class="lno">3110 </span>static void	cleanup_subexpr __ARGS((void));
<span class="lno">3111 </span>#ifdef FEAT_SYN_HL
<span class="lno">3112 </span>static void	cleanup_zsubexpr __ARGS((void));
</span></td><td class="ttd"><span class="lin">Line 3492 to 3499</span><span class="nop"><span class="lno">3492 </span>} regbehind_T;
<span class="lno">3493 </span>
<span class="lno">3494 </span>static char_u	*reg_getline __ARGS((linenr_T lnum));
</span><span class="upd"><span class="lno">3495 </span>static long	<span class="chg">bt</span>_regexec_both __ARGS((char_u *line, colnr_T col, proftime_T *tm));
<span class="lno">3496 </span>static long	regtry __ARGS((<span class="chg">bt_</span>regprog_T *prog, colnr_T col));
</span><span class="nop"><span class="lno">3497 </span>static void	cleanup_subexpr __ARGS((void));
<span class="lno">3498 </span>#ifdef FEAT_SYN_HL
<span class="lno">3499 </span>static void	cleanup_zsubexpr __ARGS((void));
</span></td></tr>
<tr><td class="ttd"><span class="lin">Line 3132 to 3137</span><span class="nop"><span class="lno">3132 </span>	*(pp) = (savep)-&gt;se_u.ptr; }
<span class="lno">3133 </span>
<span class="lno">3134 </span>static int	re_num_cmp __ARGS((long_u val, char_u *scan));
</span><span class="nop"><span class="lno"> </span>
</span><span class="nop"><span class="lno">3135 </span>static int	regmatch __ARGS((char_u *prog));
<span class="lno">3136 </span>static int	regrepeat __ARGS((char_u *p, long maxcount));
<span class="lno">3137 </span>
</span></td><td class="ttd"><span class="lin">Line 3519 to 3525</span><span class="nop"><span class="lno">3519 </span>	*(pp) = (savep)-&gt;se_u.ptr; }
<span class="lno">3520 </span>
<span class="lno">3521 </span>static int	re_num_cmp __ARGS((long_u val, char_u *scan));
</span><span class="add"><span class="lno">3522 </span>static int	match_with_backref __ARGS((linenr_T start_lnum, colnr_T start_col, linenr_T end_lnum, colnr_T end_col, int *bytelen));
</span><span class="nop"><span class="lno">3523 </span>static int	regmatch __ARGS((char_u *prog));
<span class="lno">3524 </span>static int	regrepeat __ARGS((char_u *p, long maxcount));
<span class="lno">3525 </span>
</span></td></tr>
<tr><td class="ttd"><span class="lin">Line 3163 to 3169</span><span class="nop"><span class="lno">3163 </span>/*
<span class="lno">3164 </span> * Sometimes need to save a copy of a line.  Since alloc()/free() is very
<span class="lno">3165 </span> * slow, we keep one allocated piece of memory and only re-allocate it when
</span><span class="upd"><span class="lno">3166 </span> * it&#39;s too small.  It&#39;s freed in <span class="chg">vim</span>_regexec_both() when finished.
</span><span class="nop"><span class="lno">3167 </span> */
<span class="lno">3168 </span>static char_u	*reg_tofree = NULL;
<span class="lno">3169 </span>static unsigned	reg_tofreelen;
</span></td><td class="ttd"><span class="lin">Line 3551 to 3557</span><span class="nop"><span class="lno">3551 </span>/*
<span class="lno">3552 </span> * Sometimes need to save a copy of a line.  Since alloc()/free() is very
<span class="lno">3553 </span> * slow, we keep one allocated piece of memory and only re-allocate it when
</span><span class="upd"><span class="lno">3554 </span> * it&#39;s too small.  It&#39;s freed in <span class="chg">bt</span>_regexec_both() when finished.
</span><span class="nop"><span class="lno">3555 </span> */
<span class="lno">3556 </span>static char_u	*reg_tofree = NULL;
<span class="lno">3557 </span>static unsigned	reg_tofreelen;
</span></td></tr>
<tr><td class="ttd"><span class="lin">Line 3180 to 3186</span><span class="nop"><span class="lno">3180 </span> * reg_startpos		&lt;invalid&gt;		reg_mmatch-&gt;startpos
<span class="lno">3181 </span> * reg_endpos		&lt;invalid&gt;		reg_mmatch-&gt;endpos
<span class="lno">3182 </span> * reg_win		NULL			window in which to search
</span><span class="upd"><span class="lno">3183 </span> * reg_buf		<span class="chg">&lt;invalid&gt;</span>		buffer in which to search
</span><span class="nop"><span class="lno">3184 </span> * reg_firstlnum	&lt;invalid&gt;		first line in which to search
<span class="lno">3185 </span> * reg_maxline		0			last line nr
<span class="lno">3186 </span> * reg_line_lbr		FALSE or TRUE		FALSE
</span></td><td class="ttd"><span class="lin">Line 3568 to 3574</span><span class="nop"><span class="lno">3568 </span> * reg_startpos		&lt;invalid&gt;		reg_mmatch-&gt;startpos
<span class="lno">3569 </span> * reg_endpos		&lt;invalid&gt;		reg_mmatch-&gt;endpos
<span class="lno">3570 </span> * reg_win		NULL			window in which to search
</span><span class="upd"><span class="lno">3571 </span> * reg_buf		<span class="chg">curbuf	</span>		buffer in which to search
</span><span class="nop"><span class="lno">3572 </span> * reg_firstlnum	&lt;invalid&gt;		first line in which to search
<span class="lno">3573 </span> * reg_maxline		0			last line nr
<span class="lno">3574 </span> * reg_line_lbr		FALSE or TRUE		FALSE
</span></td></tr>
<tr><td class="ttd"><span class="lin">Line 3320 to 3325</span><span class="nop"><span class="lno">3320 </span>
<span class="lno">3321 </span>/* TRUE if using multi-line regexp. */
<span class="lno">3322 </span>#define REG_MULTI	(reg_match == NULL)
</span><span class="nop"><span class="lno"> </span>
<span class="lno"> </span>
</span><span class="nop"><span class="lno">3323 </span>
<span class="lno">3324 </span>/*
<span class="lno">3325 </span> * Match a regexp against a string.
</span></td><td class="ttd"><span class="lin">Line 3708 to 3715</span><span class="nop"><span class="lno">3708 </span>
<span class="lno">3709 </span>/* TRUE if using multi-line regexp. */
<span class="lno">3710 </span>#define REG_MULTI	(reg_match == NULL)
</span><span class="add"><span class="lno">3711 </span>
<span class="lno">3712 </span>static int  bt_regexec __ARGS((regmatch_T *rmp, char_u *line, colnr_T col));
</span><span class="nop"><span class="lno">3713 </span>
<span class="lno">3714 </span>/*
<span class="lno">3715 </span> * Match a regexp against a string.
</span></td></tr>
<tr><td class="ttd"><span class="lin">Line 3328 to 3335</span><span class="nop"><span class="lno">3328 </span> *
<span class="lno">3329 </span> * Return TRUE if there is a match, FALSE if not.
<span class="lno">3330 </span> */
</span><span class="upd"><span class="lno">3331 </span>    int
<span class="lno">3332 </span><span class="chg">vim</span>_regexec(rmp, line, col)
</span><span class="nop"><span class="lno">3333 </span>    regmatch_T	*rmp;
<span class="lno">3334 </span>    char_u	*line;	/* string to match against */
<span class="lno">3335 </span>    colnr_T	col;	/* column to start looking for match */
</span></td><td class="ttd"><span class="lin">Line 3718 to 3725</span><span class="nop"><span class="lno">3718 </span> *
<span class="lno">3719 </span> * Return TRUE if there is a match, FALSE if not.
<span class="lno">3720 </span> */
</span><span class="upd"><span class="lno">3721 </span>    <span class="chg">static </span>int
<span class="lno">3722 </span><span class="chg">bt</span>_regexec(rmp, line, col)
</span><span class="nop"><span class="lno">3723 </span>    regmatch_T	*rmp;
<span class="lno">3724 </span>    char_u	*line;	/* string to match against */
<span class="lno">3725 </span>    colnr_T	col;	/* column to start looking for match */
</span></td></tr>
<tr><td class="ttd"><span class="lin">Line 3338 to 3359</span><span class="nop"><span class="lno">3338 </span>    reg_mmatch = NULL;
<span class="lno">3339 </span>    reg_maxline = 0;
<span class="lno">3340 </span>    reg_line_lbr = FALSE;
</span><span class="nop"><span class="lno"> </span>
</span><span class="nop"><span class="lno">3341 </span>    reg_win = NULL;
<span class="lno">3342 </span>    ireg_ic = rmp-&gt;rm_ic;
<span class="lno">3343 </span>#ifdef FEAT_MBYTE
</span><span class="nop"><span class="lno">3344 </span>    ireg_icombine = FALSE;
<span class="lno">3345 </span>#endif
<span class="lno">3346 </span>    ireg_maxcol = 0;
</span><span class="upd"><span class="lno">3347 </span>    return (<span class="chg">vim</span>_regexec_both(line, col, NULL) != 0);
</span><span class="nop"><span class="lno">3348 </span>}
<span class="lno">3349 </span>
<span class="lno">3350 </span>#if defined(FEAT_MODIFY_FNAME) || defined(FEAT_EVAL) \
</span><span class="nop"><span class="lno">3351 </span>	|| defined(FIND_REPLACE_DIALOG) || defined(PROTO)
</span><span class="nop"><span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
</span><span class="nop"><span class="lno">3352 </span>/*
<span class="lno">3353 </span> * Like vim_regexec(), but consider a &#34;\n&#34; in &#34;line&#34; to be a line break.
<span class="lno">3354 </span> */
</span><span class="upd"><span class="lno">3355 </span>    int
<span class="lno">3356 </span><span class="chg">vim</span>_regexec_nl(rmp, line, col)
</span><span class="nop"><span class="lno">3357 </span>    regmatch_T	*rmp;
<span class="lno">3358 </span>    char_u	*line;	/* string to match against */
<span class="lno">3359 </span>    colnr_T	col;	/* column to start looking for match */
</span></td><td class="ttd"><span class="lin">Line 3728 to 3753</span><span class="nop"><span class="lno">3728 </span>    reg_mmatch = NULL;
<span class="lno">3729 </span>    reg_maxline = 0;
<span class="lno">3730 </span>    reg_line_lbr = FALSE;
</span><span class="add"><span class="lno">3731 </span>    reg_buf = curbuf;
</span><span class="nop"><span class="lno">3732 </span>    reg_win = NULL;
<span class="lno">3733 </span>    ireg_ic = rmp-&gt;rm_ic;
<span class="lno">3734 </span>#ifdef FEAT_MBYTE
</span><span class="nop"><span class="lno">3735 </span>    ireg_icombine = FALSE;
<span class="lno">3736 </span>#endif
<span class="lno">3737 </span>    ireg_maxcol = 0;
</span><span class="upd"><span class="lno">3738 </span>    return (<span class="chg">bt</span>_regexec_both(line, col, NULL) != 0);
</span><span class="nop"><span class="lno">3739 </span>}
<span class="lno">3740 </span>
<span class="lno">3741 </span>#if defined(FEAT_MODIFY_FNAME) || defined(FEAT_EVAL) \
</span><span class="nop"><span class="lno">3742 </span>	|| defined(FIND_REPLACE_DIALOG) || defined(PROTO)
</span><span class="add"><span class="lno">3743 </span>
<span class="lno">3744 </span>static int  bt_regexec_nl __ARGS((regmatch_T *rmp, char_u *line, colnr_T col));
<span class="lno">3745 </span>
</span><span class="nop"><span class="lno">3746 </span>/*
<span class="lno">3747 </span> * Like vim_regexec(), but consider a &#34;\n&#34; in &#34;line&#34; to be a line break.
<span class="lno">3748 </span> */
</span><span class="upd"><span class="lno">3749 </span>    <span class="chg">static </span>int
<span class="lno">3750 </span><span class="chg">bt</span>_regexec_nl(rmp, line, col)
</span><span class="nop"><span class="lno">3751 </span>    regmatch_T	*rmp;
<span class="lno">3752 </span>    char_u	*line;	/* string to match against */
<span class="lno">3753 </span>    colnr_T	col;	/* column to start looking for match */
</span></td></tr>
<tr><td class="ttd"><span class="lin">Line 3362 to 3376</span><span class="nop"><span class="lno">3362 </span>    reg_mmatch = NULL;
<span class="lno">3363 </span>    reg_maxline = 0;
<span class="lno">3364 </span>    reg_line_lbr = TRUE;
</span><span class="nop"><span class="lno"> </span>
</span><span class="nop"><span class="lno">3365 </span>    reg_win = NULL;
<span class="lno">3366 </span>    ireg_ic = rmp-&gt;rm_ic;
<span class="lno">3367 </span>#ifdef FEAT_MBYTE
</span><span class="nop"><span class="lno">3368 </span>    ireg_icombine = FALSE;
<span class="lno">3369 </span>#endif
<span class="lno">3370 </span>    ireg_maxcol = 0;
</span><span class="upd"><span class="lno">3371 </span>    return (<span class="chg">vim</span>_regexec_both(line, col, NULL) != 0);
</span><span class="nop"><span class="lno">3372 </span>}
<span class="lno">3373 </span>#endif
</span><span class="nop"><span class="lno"> </span>
<span class="lno"> </span>
</span><span class="nop"><span class="lno">3374 </span>
<span class="lno">3375 </span>/*
<span class="lno">3376 </span> * Match a regexp against multiple lines.
</span></td><td class="ttd"><span class="lin">Line 3756 to 3773</span><span class="nop"><span class="lno">3756 </span>    reg_mmatch = NULL;
<span class="lno">3757 </span>    reg_maxline = 0;
<span class="lno">3758 </span>    reg_line_lbr = TRUE;
</span><span class="add"><span class="lno">3759 </span>    reg_buf = curbuf;
</span><span class="nop"><span class="lno">3760 </span>    reg_win = NULL;
<span class="lno">3761 </span>    ireg_ic = rmp-&gt;rm_ic;
<span class="lno">3762 </span>#ifdef FEAT_MBYTE
</span><span class="nop"><span class="lno">3763 </span>    ireg_icombine = FALSE;
<span class="lno">3764 </span>#endif
<span class="lno">3765 </span>    ireg_maxcol = 0;
</span><span class="upd"><span class="lno">3766 </span>    return (<span class="chg">bt</span>_regexec_both(line, col, NULL) != 0);
</span><span class="nop"><span class="lno">3767 </span>}
<span class="lno">3768 </span>#endif
</span><span class="add"><span class="lno">3769 </span>
<span class="lno">3770 </span>static long bt_regexec_multi __ARGS((regmmatch_T *rmp, win_T *win, buf_T *buf, linenr_T lnum, colnr_T col, proftime_T *tm));
</span><span class="nop"><span class="lno">3771 </span>
<span class="lno">3772 </span>/*
<span class="lno">3773 </span> * Match a regexp against multiple lines.
</span></td></tr>
<tr><td class="ttd"><span class="lin">Line 3380 to 3387</span><span class="nop"><span class="lno">3380 </span> * Return zero if there is no match.  Return number of lines contained in the
<span class="lno">3381 </span> * match otherwise.
<span class="lno">3382 </span> */
</span><span class="upd"><span class="lno">3383 </span>    long
<span class="lno">3384 </span><span class="chg">vim</span>_regexec_multi(rmp, win, buf, lnum, col, tm)
</span><span class="nop"><span class="lno">3385 </span>    regmmatch_T	*rmp;
<span class="lno">3386 </span>    win_T	*win;		/* window in which to search or NULL */
<span class="lno">3387 </span>    buf_T	*buf;		/* buffer in which to search */
</span></td><td class="ttd"><span class="lin">Line 3777 to 3784</span><span class="nop"><span class="lno">3777 </span> * Return zero if there is no match.  Return number of lines contained in the
<span class="lno">3778 </span> * match otherwise.
<span class="lno">3779 </span> */
</span><span class="upd"><span class="lno">3780 </span>    <span class="chg">static </span>long
<span class="lno">3781 </span><span class="chg">bt</span>_regexec_multi(rmp, win, buf, lnum, col, tm)
</span><span class="nop"><span class="lno">3782 </span>    regmmatch_T	*rmp;
<span class="lno">3783 </span>    win_T	*win;		/* window in which to search or NULL */
<span class="lno">3784 </span>    buf_T	*buf;		/* buffer in which to search */
</span></td></tr>
<tr><td class="ttd"><span class="lin">Line 3390 to 3396</span><span class="nop"><span class="lno">3390 </span>    proftime_T	*tm;		/* timeout limit or NULL */
<span class="lno">3391 </span>{
<span class="lno">3392 </span>    long	r;
</span><span class="del"><span class="lno">3393 </span>    buf_T	*save_curbuf = curbuf;
</span><span class="nop"><span class="lno">3394 </span>
<span class="lno">3395 </span>    reg_match = NULL;
<span class="lno">3396 </span>    reg_mmatch = rmp;
</span></td><td class="ttd"><span class="lin">Line 3787 to 3792</span><span class="nop"><span class="lno">3787 </span>    proftime_T	*tm;		/* timeout limit or NULL */
<span class="lno">3788 </span>{
<span class="lno">3789 </span>    long	r;
</span><span class="nop"><span class="lno"> </span>
</span><span class="nop"><span class="lno">3790 </span>
<span class="lno">3791 </span>    reg_match = NULL;
<span class="lno">3792 </span>    reg_mmatch = rmp;
</span></td></tr>
<tr><td class="ttd"><span class="lin">Line 3405 to 3414</span><span class="nop"><span class="lno">3405 </span>#endif
<span class="lno">3406 </span>    ireg_maxcol = rmp-&gt;rmm_maxcol;
<span class="lno">3407 </span>
</span><span class="upd"><span class="lno">3408 </span>    <span class="chg">/*</span> <span class="chg">N</span>ee<span class="chg">d t</span>o<span class="chg"> swi</span>t<span class="chg">c</span>h <span class="chg">t</span>o<span class="chg"> buffer &#34;buf&#34;</span> t<span class="chg">o </span>m<span class="chg">ake vim_iswordc(</span>)<span class="chg"> work. */</span>
</span><span class="del"><span class="lno">3409 </span>    curbuf = buf;
<span class="lno">3410 </span>    r = vim_regexec_both(NULL, col, tm);
<span class="lno">3411 </span>    curbuf = save_curbuf;
</span><span class="nop"><span class="lno">3412 </span>
<span class="lno">3413 </span>    return r;
<span class="lno">3414 </span>}
</span></td><td class="ttd"><span class="lin">Line 3801 to 3807</span><span class="nop"><span class="lno">3801 </span>#endif
<span class="lno">3802 </span>    ireg_maxcol = rmp-&gt;rmm_maxcol;
<span class="lno">3803 </span>
</span><span class="upd"><span class="lno">3804 </span>    <span class="chg">r =</span> <span class="chg">bt_reg</span>e<span class="chg">x</span>e<span class="chg">c_b</span>oth<span class="chg">(NULL,</span> <span class="chg">c</span>o<span class="chg">l,</span> tm)<span class="chg">;</span>
</span><span class="nop"><span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
</span><span class="nop"><span class="lno">3805 </span>
<span class="lno">3806 </span>    return r;
<span class="lno">3807 </span>}
</span></td></tr>
<tr><td class="ttd"><span class="lin">Line 3418 to 3429</span><span class="nop"><span class="lno">3418 </span> * lines (&#34;line&#34; is NULL, use reg_getline()).
<span class="lno">3419 </span> */
<span class="lno">3420 </span>    static long
</span><span class="upd"><span class="lno">3421 </span><span class="chg">vim</span>_regexec_both(line, col, tm)
</span><span class="nop"><span class="lno">3422 </span>    char_u	*line;
<span class="lno">3423 </span>    colnr_T	col;		/* column to start looking for match */
<span class="lno">3424 </span>    proftime_T	*tm UNUSED;	/* timeout limit or NULL */
</span><span class="nop"><span class="lno">3425 </span>{
</span><span class="upd"><span class="lno">3426 </span>    regprog_T	*prog;
</span><span class="nop"><span class="lno">3427 </span>    char_u	*s;
<span class="lno">3428 </span>    long	retval = 0L;
<span class="lno">3429 </span>
</span></td><td class="ttd"><span class="lin">Line 3811 to 3822</span><span class="nop"><span class="lno">3811 </span> * lines (&#34;line&#34; is NULL, use reg_getline()).
<span class="lno">3812 </span> */
<span class="lno">3813 </span>    static long
</span><span class="upd"><span class="lno">3814 </span><span class="chg">bt</span>_regexec_both(line, col, tm)
</span><span class="nop"><span class="lno">3815 </span>    char_u	*line;
<span class="lno">3816 </span>    colnr_T	col;		/* column to start looking for match */
<span class="lno">3817 </span>    proftime_T	*tm UNUSED;	/* timeout limit or NULL */
</span><span class="nop"><span class="lno">3818 </span>{
</span><span class="upd"><span class="lno">3819 </span>    <span class="chg">bt_</span>regprog_T	*prog;
</span><span class="nop"><span class="lno">3820 </span>    char_u	*s;
<span class="lno">3821 </span>    long	retval = 0L;
<span class="lno">3822 </span>
</span></td></tr>
<tr><td class="ttd"><span class="lin">Line 3449 to 3462</span><span class="nop"><span class="lno">3449 </span>
<span class="lno">3450 </span>    if (REG_MULTI)
<span class="lno">3451 </span>    {
</span><span class="upd"><span class="lno">3452 </span>	prog = reg_mmatch-&gt;regprog;
</span><span class="nop"><span class="lno">3453 </span>	line = reg_getline((linenr_T)0);
<span class="lno">3454 </span>	reg_startpos = reg_mmatch-&gt;startpos;
<span class="lno">3455 </span>	reg_endpos = reg_mmatch-&gt;endpos;
</span><span class="nop"><span class="lno">3456 </span>    }
<span class="lno">3457 </span>    else
<span class="lno">3458 </span>    {
</span><span class="upd"><span class="lno">3459 </span>	prog = reg_match-&gt;regprog;
</span><span class="nop"><span class="lno">3460 </span>	reg_startp = reg_match-&gt;startp;
<span class="lno">3461 </span>	reg_endp = reg_match-&gt;endp;
<span class="lno">3462 </span>    }
</span></td><td class="ttd"><span class="lin">Line 3842 to 3855</span><span class="nop"><span class="lno">3842 </span>
<span class="lno">3843 </span>    if (REG_MULTI)
<span class="lno">3844 </span>    {
</span><span class="upd"><span class="lno">3845 </span>	prog = <span class="chg">(bt_regprog_T *)</span>reg_mmatch-&gt;regprog;
</span><span class="nop"><span class="lno">3846 </span>	line = reg_getline((linenr_T)0);
<span class="lno">3847 </span>	reg_startpos = reg_mmatch-&gt;startpos;
<span class="lno">3848 </span>	reg_endpos = reg_mmatch-&gt;endpos;
</span><span class="nop"><span class="lno">3849 </span>    }
<span class="lno">3850 </span>    else
<span class="lno">3851 </span>    {
</span><span class="upd"><span class="lno">3852 </span>	prog = <span class="chg">(bt_regprog_T *)</span>reg_match-&gt;regprog;
</span><span class="nop"><span class="lno">3853 </span>	reg_startp = reg_match-&gt;startp;
<span class="lno">3854 </span>	reg_endp = reg_match-&gt;endp;
<span class="lno">3855 </span>    }
</span></td></tr>
<tr><td class="ttd"><span class="lin">Line 3538 to 3543</span><span class="nop"><span class="lno">3538 </span>
<span class="lno">3539 </span>    regline = line;
<span class="lno">3540 </span>    reglnum = 0;
</span><span class="nop"><span class="lno"> </span>
</span><span class="nop"><span class="lno">3541 </span>
<span class="lno">3542 </span>    /* Simplest case: Anchored match need be tried only once. */
<span class="lno">3543 </span>    if (prog-&gt;reganch)
</span></td><td class="ttd"><span class="lin">Line 3931 to 3937</span><span class="nop"><span class="lno">3931 </span>
<span class="lno">3932 </span>    regline = line;
<span class="lno">3933 </span>    reglnum = 0;
</span><span class="add"><span class="lno">3934 </span>    reg_toolong = FALSE;
</span><span class="nop"><span class="lno">3935 </span>
<span class="lno">3936 </span>    /* Simplest case: Anchored match need be tried only once. */
<span class="lno">3937 </span>    if (prog-&gt;reganch)
</span></td></tr>
<tr><td class="ttd"><span class="lin">Line 3697 to 3703</span><span class="nop"><span class="lno">3697 </span> */
<span class="lno">3698 </span>    static long
<span class="lno">3699 </span>regtry(prog, col)
</span><span class="upd"><span class="lno">3700 </span>    regprog_T<span class="chg">	</span>*prog;
</span><span class="nop"><span class="lno">3701 </span>    colnr_T	col;
<span class="lno">3702 </span>{
<span class="lno">3703 </span>    reginput = regline + col;
</span></td><td class="ttd"><span class="lin">Line 4091 to 4097</span><span class="nop"><span class="lno">4091 </span> */
<span class="lno">4092 </span>    static long
<span class="lno">4093 </span>regtry(prog, col)
</span><span class="upd"><span class="lno">4094 </span>    <span class="chg">bt_</span>regprog_T<span class="chg">    </span>*prog;
</span><span class="nop"><span class="lno">4095 </span>    colnr_T	col;
<span class="lno">4096 </span>{
<span class="lno">4097 </span>    reginput = regline + col;
</span></td></tr>
<tr><td class="ttd"><span class="lin">Line 3781 to 3792</span><span class="nop"><span class="lno">3781 </span>reg_prev_class()
<span class="lno">3782 </span>{
<span class="lno">3783 </span>    if (reginput &gt; regline)
</span><span class="upd"><span class="lno">3784 </span>	return mb_get_class(reginput - 1
<span class="lno">3785 </span>			<span class="chg">	 </span>    - (*mb_head_off)(regline, reginput - 1));
</span><span class="nop"><span class="lno">3786 </span>    return -1;
<span class="lno">3787 </span>}
<span class="lno">3788 </span>
</span><span class="nop"><span class="lno">3789 </span>#endif
</span><span class="nop"><span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
</span><span class="nop"><span class="lno">3790 </span>#define ADVANCE_REGINPUT() mb_ptr_adv(reginput)
<span class="lno">3791 </span>
<span class="lno">3792 </span>/*
</span></td><td class="ttd"><span class="lin">Line 4175 to 4265</span><span class="nop"><span class="lno">4175 </span>reg_prev_class()
<span class="lno">4176 </span>{
<span class="lno">4177 </span>    if (reginput &gt; regline)
</span><span class="upd"><span class="lno">4178 </span>	return mb_get_class<span class="chg">_buf</span>(reginput - 1
<span class="lno">4179 </span>			    - (*mb_head_off)(regline, reginput - 1)<span class="chg">, reg_buf</span>);
</span><span class="nop"><span class="lno">4180 </span>    return -1;
<span class="lno">4181 </span>}
<span class="lno">4182 </span>
</span><span class="nop"><span class="lno">4183 </span>#endif
</span><span class="add"><span class="lno">4184 </span>#ifdef FEAT_VISUAL
<span class="lno">4185 </span>static int reg_match_visual __ARGS((void));
<span class="lno">4186 </span>
<span class="lno">4187 </span>/*
<span class="lno">4188 </span> * Return TRUE if the current reginput position matches the Visual area.
<span class="lno">4189 </span> */
<span class="lno">4190 </span>    static int
<span class="lno">4191 </span>reg_match_visual()
<span class="lno">4192 </span>{
<span class="lno">4193 </span>    pos_T	top, bot;
<span class="lno">4194 </span>    linenr_T    lnum;
<span class="lno">4195 </span>    colnr_T	col;
<span class="lno">4196 </span>    win_T	*wp = reg_win == NULL ? curwin : reg_win;
<span class="lno">4197 </span>    int		mode;
<span class="lno">4198 </span>    colnr_T	start, end;
<span class="lno">4199 </span>    colnr_T	start2, end2;
<span class="lno">4200 </span>    colnr_T	cols;
<span class="lno">4201 </span>
<span class="lno">4202 </span>    /* Check if the buffer is the current buffer. */
<span class="lno">4203 </span>    if (reg_buf != curbuf || VIsual.lnum == 0)
<span class="lno">4204 </span>	return FALSE;
<span class="lno">4205 </span>
<span class="lno">4206 </span>    if (VIsual_active)
<span class="lno">4207 </span>    {
<span class="lno">4208 </span>	if (lt(VIsual, wp-&gt;w_cursor))
<span class="lno">4209 </span>	{
<span class="lno">4210 </span>	    top = VIsual;
<span class="lno">4211 </span>	    bot = wp-&gt;w_cursor;
<span class="lno">4212 </span>	}
<span class="lno">4213 </span>	else
<span class="lno">4214 </span>	{
<span class="lno">4215 </span>	    top = wp-&gt;w_cursor;
<span class="lno">4216 </span>	    bot = VIsual;
<span class="lno">4217 </span>	}
<span class="lno">4218 </span>	mode = VIsual_mode;
<span class="lno">4219 </span>    }
<span class="lno">4220 </span>    else
<span class="lno">4221 </span>    {
<span class="lno">4222 </span>	if (lt(curbuf-&gt;b_visual.vi_start, curbuf-&gt;b_visual.vi_end))
<span class="lno">4223 </span>	{
<span class="lno">4224 </span>	    top = curbuf-&gt;b_visual.vi_start;
<span class="lno">4225 </span>	    bot = curbuf-&gt;b_visual.vi_end;
<span class="lno">4226 </span>	}
<span class="lno">4227 </span>	else
<span class="lno">4228 </span>	{
<span class="lno">4229 </span>	    top = curbuf-&gt;b_visual.vi_end;
<span class="lno">4230 </span>	    bot = curbuf-&gt;b_visual.vi_start;
<span class="lno">4231 </span>	}
<span class="lno">4232 </span>	mode = curbuf-&gt;b_visual.vi_mode;
<span class="lno">4233 </span>    }
<span class="lno">4234 </span>    lnum = reglnum + reg_firstlnum;
<span class="lno">4235 </span>    if (lnum &lt; top.lnum || lnum &gt; bot.lnum)
<span class="lno">4236 </span>	return FALSE;
<span class="lno">4237 </span>
<span class="lno">4238 </span>    if (mode == &#39;v&#39;)
<span class="lno">4239 </span>    {
<span class="lno">4240 </span>	col = (colnr_T)(reginput - regline);
<span class="lno">4241 </span>	if ((lnum == top.lnum &amp;&amp; col &lt; top.col)
<span class="lno">4242 </span>		|| (lnum == bot.lnum &amp;&amp; col &gt;= bot.col + (*p_sel != &#39;e&#39;)))
<span class="lno">4243 </span>	    return FALSE;
<span class="lno">4244 </span>    }
<span class="lno">4245 </span>    else if (mode == Ctrl_V)
<span class="lno">4246 </span>    {
<span class="lno">4247 </span>	getvvcol(wp, &amp;top, &amp;start, NULL, &amp;end);
<span class="lno">4248 </span>	getvvcol(wp, &amp;bot, &amp;start2, NULL, &amp;end2);
<span class="lno">4249 </span>	if (start2 &lt; start)
<span class="lno">4250 </span>	    start = start2;
<span class="lno">4251 </span>	if (end2 &gt; end)
<span class="lno">4252 </span>	    end = end2;
<span class="lno">4253 </span>	if (top.col == MAXCOL || bot.col == MAXCOL)
<span class="lno">4254 </span>	    end = MAXCOL;
<span class="lno">4255 </span>	cols = win_linetabsize(wp, regline, (colnr_T)(reginput - regline));
<span class="lno">4256 </span>	if (cols &lt; start || cols &gt; end - (*p_sel == &#39;e&#39;))
<span class="lno">4257 </span>	    return FALSE;
<span class="lno">4258 </span>    }
<span class="lno">4259 </span>    return TRUE;
<span class="lno">4260 </span>}
<span class="lno">4261 </span>#endif
<span class="lno">4262 </span>
</span><span class="nop"><span class="lno">4263 </span>#define ADVANCE_REGINPUT() mb_ptr_adv(reginput)
<span class="lno">4264 </span>
<span class="lno">4265 </span>/*
</span></td></tr>
<tr><td class="ttd"><span class="lin">Line 3829 to 3835</span><span class="nop"><span class="lno">3829 </span>#define RA_NOMATCH	5	/* didn&#39;t match */
<span class="lno">3830 </span>
<span class="lno">3831 </span>  /* Make &#34;regstack&#34; and &#34;backpos&#34; empty.  They are allocated and freed in
</span><span class="upd"><span class="lno">3832 </span>   * <span class="chg">vim</span>_regexec_both() to reduce malloc()/free() calls. */
</span><span class="nop"><span class="lno">3833 </span>  regstack.ga_len = 0;
<span class="lno">3834 </span>  backpos.ga_len = 0;
<span class="lno">3835 </span>
</span></td><td class="ttd"><span class="lin">Line 4302 to 4308</span><span class="nop"><span class="lno">4302 </span>#define RA_NOMATCH	5	/* didn&#39;t match */
<span class="lno">4303 </span>
<span class="lno">4304 </span>  /* Make &#34;regstack&#34; and &#34;backpos&#34; empty.  They are allocated and freed in
</span><span class="upd"><span class="lno">4305 </span>   * <span class="chg">bt</span>_regexec_both() to reduce malloc()/free() calls. */
</span><span class="nop"><span class="lno">4306 </span>  regstack.ga_len = 0;
<span class="lno">4307 </span>  backpos.ga_len = 0;
<span class="lno">4308 </span>
</span></td></tr>
<tr><td class="ttd"><span class="lin">Line 3838 to 3851</span><span class="nop"><span class="lno">3838 </span>   */
<span class="lno">3839 </span>  for (;;)
<span class="lno">3840 </span>  {
</span><span class="upd"><span class="lno">3841 </span>    /* Some patterns my cause a long time to match, even though they are not
</span><span class="nop"><span class="lno">3842 </span>     * illegal.  E.g., &#34;\([a-z]\+\)\+Q&#34;.  Allow breaking them with CTRL-C. */
<span class="lno">3843 </span>    fast_breakcheck();
<span class="lno">3844 </span>
</span><span class="nop"><span class="lno">3845 </span>#ifdef DEBUG
<span class="lno">3846 </span>    if (scan != NULL &amp;&amp; regnarrate)
<span class="lno">3847 </span>    {
</span><span class="upd"><span class="lno">3848 </span>	mch_errmsg(regprop(scan));
</span><span class="nop"><span class="lno">3849 </span>	mch_errmsg(&#34;(\n&#34;);
<span class="lno">3850 </span>    }
<span class="lno">3851 </span>#endif
</span></td><td class="ttd"><span class="lin">Line 4311 to 4324</span><span class="nop"><span class="lno">4311 </span>   */
<span class="lno">4312 </span>  for (;;)
<span class="lno">4313 </span>  {
</span><span class="upd"><span class="lno">4314 </span>    /* Some patterns m<span class="chg">a</span>y cause a long time to match, even though they are not
</span><span class="nop"><span class="lno">4315 </span>     * illegal.  E.g., &#34;\([a-z]\+\)\+Q&#34;.  Allow breaking them with CTRL-C. */
<span class="lno">4316 </span>    fast_breakcheck();
<span class="lno">4317 </span>
</span><span class="nop"><span class="lno">4318 </span>#ifdef DEBUG
<span class="lno">4319 </span>    if (scan != NULL &amp;&amp; regnarrate)
<span class="lno">4320 </span>    {
</span><span class="upd"><span class="lno">4321 </span>	mch_errmsg(<span class="chg">(char *)</span>regprop(scan));
</span><span class="nop"><span class="lno">4322 </span>	mch_errmsg(&#34;(\n&#34;);
<span class="lno">4323 </span>    }
<span class="lno">4324 </span>#endif
</span></td></tr>
<tr><td class="ttd"><span class="lin">Line 3866 to 3872</span><span class="nop"><span class="lno">3866 </span>#ifdef DEBUG
<span class="lno">3867 </span>	if (regnarrate)
<span class="lno">3868 </span>	{
</span><span class="upd"><span class="lno">3869 </span>	    mch_errmsg(regprop(scan));
</span><span class="nop"><span class="lno">3870 </span>	    mch_errmsg(&#34;...\n&#34;);
<span class="lno">3871 </span># ifdef FEAT_SYN_HL
<span class="lno">3872 </span>	    if (re_extmatch_in != NULL)
</span></td><td class="ttd"><span class="lin">Line 4339 to 4345</span><span class="nop"><span class="lno">4339 </span>#ifdef DEBUG
<span class="lno">4340 </span>	if (regnarrate)
<span class="lno">4341 </span>	{
</span><span class="upd"><span class="lno">4342 </span>	    mch_errmsg(<span class="chg">(char *)</span>regprop(scan));
</span><span class="nop"><span class="lno">4343 </span>	    mch_errmsg(&#34;...\n&#34;);
<span class="lno">4344 </span># ifdef FEAT_SYN_HL
<span class="lno">4345 </span>	    if (re_extmatch_in != NULL)
</span></td></tr>
<tr><td class="ttd"><span class="lin">Line 3878 to 3884</span><span class="nop"><span class="lno">3878 </span>		{
<span class="lno">3879 </span>		    mch_errmsg(&#34;    \&#34;&#34;);
<span class="lno">3880 </span>		    if (re_extmatch_in-&gt;matches[i] != NULL)
</span><span class="upd"><span class="lno">3881 </span>			mch_errmsg(re_extmatch_in-&gt;matches[i]);
</span><span class="nop"><span class="lno">3882 </span>		    mch_errmsg(&#34;\&#34;\n&#34;);
<span class="lno">3883 </span>		}
<span class="lno">3884 </span>	    }
</span></td><td class="ttd"><span class="lin">Line 4351 to 4357</span><span class="nop"><span class="lno">4351 </span>		{
<span class="lno">4352 </span>		    mch_errmsg(&#34;    \&#34;&#34;);
<span class="lno">4353 </span>		    if (re_extmatch_in-&gt;matches[i] != NULL)
</span><span class="upd"><span class="lno">4354 </span>			mch_errmsg(<span class="chg">(char *)</span>re_extmatch_in-&gt;matches[i]);
</span><span class="nop"><span class="lno">4355 </span>		    mch_errmsg(&#34;\&#34;\n&#34;);
<span class="lno">4356 </span>		}
<span class="lno">4357 </span>	    }
</span></td></tr>
<tr><td class="ttd"><span class="lin">Line 3944 to 3959</span><span class="nop"><span class="lno">3944 </span>	    break;
<span class="lno">3945 </span>
<span class="lno">3946 </span>	  case RE_MARK:
</span><span class="upd"><span class="lno">3947 </span>	    /* Compare the mark position to the match position. <span class="chg"> NOTE: Always</span>
</span><span class="del"><span class="lno">3948 </span>	     * uses the current buffer. */
</span><span class="nop"><span class="lno">3949 </span>	    {
<span class="lno">3950 </span>		int	mark = OPERAND(scan)[0];
<span class="lno">3951 </span>		int	cmp = OPERAND(scan)[1];
</span><span class="nop"><span class="lno">3952 </span>		pos_T	*pos;
<span class="lno">3953 </span>
</span><span class="upd"><span class="lno">3954 </span>		pos = getmark(mark, FALSE);
</span><span class="nop"><span class="lno">3955 </span>		if (pos == NULL		     /* mark doesn&#39;t exist */
</span><span class="upd"><span class="lno">3956 </span>			|| pos-&gt;lnum &lt;= 0    /* mark isn&#39;t set <span class="chg">(</span>in <span class="chg">cu</span>rbuf<span class="chg">)</span> */
</span><span class="nop"><span class="lno">3957 </span>			|| (pos-&gt;lnum == reglnum + reg_firstlnum
<span class="lno">3958 </span>				? (pos-&gt;col == (colnr_T)(reginput - regline)
<span class="lno">3959 </span>				    ? (cmp == &#39;&lt;&#39; || cmp == &#39;&gt;&#39;)
</span></td><td class="ttd"><span class="lin">Line 4417 to 4431</span><span class="nop"><span class="lno">4417 </span>	    break;
<span class="lno">4418 </span>
<span class="lno">4419 </span>	  case RE_MARK:
</span><span class="upd"><span class="lno">4420 </span>	    /* Compare the mark position to the match position. <span class="chg">*/</span>
</span><span class="nop"><span class="lno"> </span>
</span><span class="nop"><span class="lno">4421 </span>	    {
<span class="lno">4422 </span>		int	mark = OPERAND(scan)[0];
<span class="lno">4423 </span>		int	cmp = OPERAND(scan)[1];
</span><span class="nop"><span class="lno">4424 </span>		pos_T	*pos;
<span class="lno">4425 </span>
</span><span class="upd"><span class="lno">4426 </span>		pos = getmark<span class="chg">_buf</span>(<span class="chg">reg_buf, </span>mark, FALSE);
</span><span class="nop"><span class="lno">4427 </span>		if (pos == NULL		     /* mark doesn&#39;t exist */
</span><span class="upd"><span class="lno">4428 </span>			|| pos-&gt;lnum &lt;= 0    /* mark isn&#39;t set in r<span class="chg">eg_</span>buf */
</span><span class="nop"><span class="lno">4429 </span>			|| (pos-&gt;lnum == reglnum + reg_firstlnum
<span class="lno">4430 </span>				? (pos-&gt;col == (colnr_T)(reginput - regline)
<span class="lno">4431 </span>				    ? (cmp == &#39;&lt;&#39; || cmp == &#39;&gt;&#39;)
</span></td></tr>
<tr><td class="ttd"><span class="lin">Line 3969 to 4048</span><span class="nop"><span class="lno">3969 </span>
<span class="lno">3970 </span>	  case RE_VISUAL:
<span class="lno">3971 </span>#ifdef FEAT_VISUAL
</span><span class="upd"><span class="lno">3972 </span>	    <span class="chg">/* Check </span>if th<span class="chg">e buffer </span>is<span class="chg"> the current b</span>u<span class="chg">ffer. </span>a<span class="chg">nd whether the</span>
<span class="lno">3973 </span><span class="chg">	     * position is i</span>n<span class="chg">si</span>d<span class="chg">e the V</span>i<span class="chg">sual area. */</span>
</span><span class="del"><span class="lno">3974 </span>	    if (reg_buf != curbuf || VIsual.lnum == 0)
</span><span class="nop"><span class="lno">3975 </span>		status = RA_NOMATCH;
</span><span class="del"><span class="lno">3976 </span>	    else
<span class="lno">3977 </span>	    {
<span class="lno">3978 </span>		pos_T	    top, bot;
<span class="lno">3979 </span>		linenr_T    lnum;
<span class="lno">3980 </span>		colnr_T	    col;
<span class="lno">3981 </span>		win_T	    *wp = reg_win == NULL ? curwin : reg_win;
<span class="lno">3982 </span>		int	    mode;
<span class="lno">3983 </span>
<span class="lno">3984 </span>		if (VIsual_active)
<span class="lno">3985 </span>		{
<span class="lno">3986 </span>		    if (lt(VIsual, wp-&gt;w_cursor))
<span class="lno">3987 </span>		    {
<span class="lno">3988 </span>			top = VIsual;
<span class="lno">3989 </span>			bot = wp-&gt;w_cursor;
<span class="lno">3990 </span>		    }
<span class="lno">3991 </span>		    else
<span class="lno">3992 </span>		    {
<span class="lno">3993 </span>			top = wp-&gt;w_cursor;
<span class="lno">3994 </span>			bot = VIsual;
<span class="lno">3995 </span>		    }
<span class="lno">3996 </span>		    mode = VIsual_mode;
<span class="lno">3997 </span>		}
<span class="lno">3998 </span>		else
<span class="lno">3999 </span>		{
<span class="lno">4000 </span>		    if (lt(curbuf-&gt;b_visual.vi_start, curbuf-&gt;b_visual.vi_end))
<span class="lno">4001 </span>		    {
<span class="lno">4002 </span>			top = curbuf-&gt;b_visual.vi_start;
<span class="lno">4003 </span>			bot = curbuf-&gt;b_visual.vi_end;
<span class="lno">4004 </span>		    }
<span class="lno">4005 </span>		    else
<span class="lno">4006 </span>		    {
<span class="lno">4007 </span>			top = curbuf-&gt;b_visual.vi_end;
<span class="lno">4008 </span>			bot = curbuf-&gt;b_visual.vi_start;
<span class="lno">4009 </span>		    }
<span class="lno">4010 </span>		    mode = curbuf-&gt;b_visual.vi_mode;
<span class="lno">4011 </span>		}
<span class="lno">4012 </span>		lnum = reglnum + reg_firstlnum;
<span class="lno">4013 </span>		col = (colnr_T)(reginput - regline);
<span class="lno">4014 </span>		if (lnum &lt; top.lnum || lnum &gt; bot.lnum)
<span class="lno">4015 </span>		    status = RA_NOMATCH;
<span class="lno">4016 </span>		else if (mode == &#39;v&#39;)
<span class="lno">4017 </span>		{
<span class="lno">4018 </span>		    if ((lnum == top.lnum &amp;&amp; col &lt; top.col)
<span class="lno">4019 </span>			    || (lnum == bot.lnum
<span class="lno">4020 </span>					 &amp;&amp; col &gt;= bot.col + (*p_sel != &#39;e&#39;)))
<span class="lno">4021 </span>			status = RA_NOMATCH;
<span class="lno">4022 </span>		}
<span class="lno">4023 </span>		else if (mode == Ctrl_V)
<span class="lno">4024 </span>		{
<span class="lno">4025 </span>		    colnr_T	    start, end;
<span class="lno">4026 </span>		    colnr_T	    start2, end2;
<span class="lno">4027 </span>		    colnr_T	    cols;
<span class="lno">4028 </span>
<span class="lno">4029 </span>		    getvvcol(wp, &amp;top, &amp;start, NULL, &amp;end);
<span class="lno">4030 </span>		    getvvcol(wp, &amp;bot, &amp;start2, NULL, &amp;end2);
<span class="lno">4031 </span>		    if (start2 &lt; start)
<span class="lno">4032 </span>			start = start2;
<span class="lno">4033 </span>		    if (end2 &gt; end)
<span class="lno">4034 </span>			end = end2;
<span class="lno">4035 </span>		    if (top.col == MAXCOL || bot.col == MAXCOL)
<span class="lno">4036 </span>			end = MAXCOL;
<span class="lno">4037 </span>		    cols = win_linetabsize(wp,
<span class="lno">4038 </span>				      regline, (colnr_T)(reginput - regline));
<span class="lno">4039 </span>		    if (cols &lt; start || cols &gt; end - (*p_sel == &#39;e&#39;))
<span class="lno">4040 </span>			status = RA_NOMATCH;
<span class="lno">4041 </span>		}
<span class="lno">4042 </span>	    }
<span class="lno">4043 </span>#else
<span class="lno">4044 </span>	    status = RA_NOMATCH;
<span class="lno">4045 </span>#endif
</span><span class="nop"><span class="lno">4046 </span>	    break;
<span class="lno">4047 </span>
<span class="lno">4048 </span>	  case RE_LNUM:
</span></td><td class="ttd"><span class="lin">Line 4441 to 4449</span><span class="nop"><span class="lno">4441 </span>
<span class="lno">4442 </span>	  case RE_VISUAL:
<span class="lno">4443 </span>#ifdef FEAT_VISUAL
</span><span class="upd"><span class="lno">4444 </span>	    if <span class="chg">(!reg_ma</span>t<span class="chg">c</span>h<span class="chg">_v</span>isua<span class="chg">l())</span>
<span class="lno">4445 </span><span class="chg">#e</span>ndi<span class="chg">f</span>
</span><span class="nop"><span class="lno"> </span>
</span><span class="nop"><span class="lno">4446 </span>		status = RA_NOMATCH;
</span><span class="nop"><span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
</span><span class="nop"><span class="lno">4447 </span>	    break;
<span class="lno">4448 </span>
<span class="lno">4449 </span>	  case RE_LNUM:
</span></td></tr>
<tr><td class="ttd"><span class="lin">Line 4072 to 4078</span><span class="nop"><span class="lno">4072 </span>		int this_class;
<span class="lno">4073 </span>
<span class="lno">4074 </span>		/* Get class of current and previous char (if it exists). */
</span><span class="upd"><span class="lno">4075 </span>		this_class = mb_get_class(reginput);
</span><span class="nop"><span class="lno">4076 </span>		if (this_class &lt;= 1)
<span class="lno">4077 </span>		    status = RA_NOMATCH;  /* not on a word at all */
<span class="lno">4078 </span>		else if (reg_prev_class() == this_class)
</span></td><td class="ttd"><span class="lin">Line 4473 to 4479</span><span class="nop"><span class="lno">4473 </span>		int this_class;
<span class="lno">4474 </span>
<span class="lno">4475 </span>		/* Get class of current and previous char (if it exists). */
</span><span class="upd"><span class="lno">4476 </span>		this_class = mb_get_class<span class="chg">_buf</span>(reginput<span class="chg">, reg_buf</span>);
</span><span class="nop"><span class="lno">4477 </span>		if (this_class &lt;= 1)
<span class="lno">4478 </span>		    status = RA_NOMATCH;  /* not on a word at all */
<span class="lno">4479 </span>		else if (reg_prev_class() == this_class)
</span></td></tr>
<tr><td class="ttd"><span class="lin">Line 4081 to 4088</span><span class="nop"><span class="lno">4081 </span>#endif
<span class="lno">4082 </span>	    else
<span class="lno">4083 </span>	    {
</span><span class="upd"><span class="lno">4084 </span>		if (!vim_iswordc(c)
<span class="lno">4085 </span>			<span class="chg">||</span> <span class="chg">(reginput</span> <span class="chg">&gt; regline</span> &amp;&amp; vim_iswordc(reginput[-1])))
</span><span class="nop"><span class="lno">4086 </span>		    status = RA_NOMATCH;
<span class="lno">4087 </span>	    }
<span class="lno">4088 </span>	    break;
</span></td><td class="ttd"><span class="lin">Line 4482 to 4489</span><span class="nop"><span class="lno">4482 </span>#endif
<span class="lno">4483 </span>	    else
<span class="lno">4484 </span>	    {
</span><span class="upd"><span class="lno">4485 </span>		if (!vim_iswordc<span class="chg">_buf</span>(c<span class="chg">, reg_buf</span>)<span class="chg"> || (reginput &gt; regline</span>
<span class="lno">4486 </span><span class="chg">	</span>			   &amp;&amp; vim_iswordc<span class="chg">_buf</span>(reginput[-1]<span class="chg">, reg_buf</span>)))
</span><span class="nop"><span class="lno">4487 </span>		    status = RA_NOMATCH;
<span class="lno">4488 </span>	    }
<span class="lno">4489 </span>	    break;
</span></td></tr>
<tr><td class="ttd"><span class="lin">Line 4096 to 4102</span><span class="nop"><span class="lno">4096 </span>		int this_class, prev_class;
<span class="lno">4097 </span>
<span class="lno">4098 </span>		/* Get class of current and previous char (if it exists). */
</span><span class="upd"><span class="lno">4099 </span>		this_class = mb_get_class(reginput);
</span><span class="nop"><span class="lno">4100 </span>		prev_class = reg_prev_class();
<span class="lno">4101 </span>		if (this_class == prev_class
<span class="lno">4102 </span>			|| prev_class == 0 || prev_class == 1)
</span></td><td class="ttd"><span class="lin">Line 4497 to 4503</span><span class="nop"><span class="lno">4497 </span>		int this_class, prev_class;
<span class="lno">4498 </span>
<span class="lno">4499 </span>		/* Get class of current and previous char (if it exists). */
</span><span class="upd"><span class="lno">4500 </span>		this_class = mb_get_class<span class="chg">_buf</span>(reginput<span class="chg">, reg_buf</span>);
</span><span class="nop"><span class="lno">4501 </span>		prev_class = reg_prev_class();
<span class="lno">4502 </span>		if (this_class == prev_class
<span class="lno">4503 </span>			|| prev_class == 0 || prev_class == 1)
</span></td></tr>
<tr><td class="ttd"><span class="lin">Line 4105 to 4117</span><span class="nop"><span class="lno">4105 </span>#endif
<span class="lno">4106 </span>	    else
<span class="lno">4107 </span>	    {
</span><span class="upd"><span class="lno">4108 </span>		if (!vim_iswordc(reginput[-1])
<span class="lno">4109 </span>			|| (reginput[0] != NUL &amp;&amp; vim_iswordc(c)))
</span><span class="nop"><span class="lno">4110 </span>		    status = RA_NOMATCH;
<span class="lno">4111 </span>	    }
<span class="lno">4112 </span>	    break; /* Matched with EOW */
</span><span class="nop"><span class="lno">4113 </span>
<span class="lno">4114 </span>	  case ANY:
</span><span class="nop"><span class="lno"> </span>
</span><span class="nop"><span class="lno">4115 </span>	    if (c == NUL)
<span class="lno">4116 </span>		status = RA_NOMATCH;
<span class="lno">4117 </span>	    else
</span></td><td class="ttd"><span class="lin">Line 4506 to 4519</span><span class="nop"><span class="lno">4506 </span>#endif
<span class="lno">4507 </span>	    else
<span class="lno">4508 </span>	    {
</span><span class="upd"><span class="lno">4509 </span>		if (!vim_iswordc<span class="chg">_buf</span>(reginput[-1]<span class="chg">, reg_buf</span>)
<span class="lno">4510 </span>			|| (reginput[0] != NUL &amp;&amp; vim_iswordc<span class="chg">_buf</span>(c<span class="chg">, reg_buf</span>)))
</span><span class="nop"><span class="lno">4511 </span>		    status = RA_NOMATCH;
<span class="lno">4512 </span>	    }
<span class="lno">4513 </span>	    break; /* Matched with EOW */
</span><span class="nop"><span class="lno">4514 </span>
<span class="lno">4515 </span>	  case ANY:
</span><span class="add"><span class="lno">4516 </span>	    /* ANY does not match new lines. */
</span><span class="nop"><span class="lno">4517 </span>	    if (c == NUL)
<span class="lno">4518 </span>		status = RA_NOMATCH;
<span class="lno">4519 </span>	    else
</span></td></tr>
<tr><td class="ttd"><span class="lin">Line 4133 to 4146</span><span class="nop"><span class="lno">4133 </span>	    break;
<span class="lno">4134 </span>
<span class="lno">4135 </span>	  case KWORD:
</span><span class="upd"><span class="lno">4136 </span>	    if (!vim_iswordp(reginput))
</span><span class="nop"><span class="lno">4137 </span>		status = RA_NOMATCH;
<span class="lno">4138 </span>	    else
<span class="lno">4139 </span>		ADVANCE_REGINPUT();
</span><span class="nop"><span class="lno">4140 </span>	    break;
<span class="lno">4141 </span>
<span class="lno">4142 </span>	  case SKWORD:
</span><span class="upd"><span class="lno">4143 </span>	    if (VIM_ISDIGIT(*reginput) || !vim_iswordp(reginput))
</span><span class="nop"><span class="lno">4144 </span>		status = RA_NOMATCH;
<span class="lno">4145 </span>	    else
<span class="lno">4146 </span>		ADVANCE_REGINPUT();
</span></td><td class="ttd"><span class="lin">Line 4535 to 4548</span><span class="nop"><span class="lno">4535 </span>	    break;
<span class="lno">4536 </span>
<span class="lno">4537 </span>	  case KWORD:
</span><span class="upd"><span class="lno">4538 </span>	    if (!vim_iswordp<span class="chg">_buf</span>(reginput<span class="chg">, reg_buf</span>))
</span><span class="nop"><span class="lno">4539 </span>		status = RA_NOMATCH;
<span class="lno">4540 </span>	    else
<span class="lno">4541 </span>		ADVANCE_REGINPUT();
</span><span class="nop"><span class="lno">4542 </span>	    break;
<span class="lno">4543 </span>
<span class="lno">4544 </span>	  case SKWORD:
</span><span class="upd"><span class="lno">4545 </span>	    if (VIM_ISDIGIT(*reginput) || !vim_iswordp<span class="chg">_buf</span>(reginput<span class="chg">, reg_buf</span>))
</span><span class="nop"><span class="lno">4546 </span>		status = RA_NOMATCH;
<span class="lno">4547 </span>	    else
<span class="lno">4548 </span>		ADVANCE_REGINPUT();
</span></td></tr>
<tr><td class="ttd"><span class="lin">Line 4161 to 4174</span><span class="nop"><span class="lno">4161 </span>	    break;
<span class="lno">4162 </span>
<span class="lno">4163 </span>	  case PRINT:
</span><span class="upd"><span class="lno">4164 </span>	    if (pt<span class="chg">r</span>2<span class="chg">cells</span>(reginput)<span class="chg"> != 1</span>)
</span><span class="nop"><span class="lno">4165 </span>		status = RA_NOMATCH;
<span class="lno">4166 </span>	    else
<span class="lno">4167 </span>		ADVANCE_REGINPUT();
</span><span class="nop"><span class="lno">4168 </span>	    break;
<span class="lno">4169 </span>
<span class="lno">4170 </span>	  case SPRINT:
</span><span class="upd"><span class="lno">4171 </span>	    if (VIM_ISDIGIT(*reginput) || pt<span class="chg">r</span>2<span class="chg">cells</span>(reginput)<span class="chg"> != 1</span>)
</span><span class="nop"><span class="lno">4172 </span>		status = RA_NOMATCH;
<span class="lno">4173 </span>	    else
<span class="lno">4174 </span>		ADVANCE_REGINPUT();
</span></td><td class="ttd"><span class="lin">Line 4563 to 4576</span><span class="nop"><span class="lno">4563 </span>	    break;
<span class="lno">4564 </span>
<span class="lno">4565 </span>	  case PRINT:
</span><span class="upd"><span class="lno">4566 </span>	    if (<span class="chg">!vim_is</span>p<span class="chg">rin</span>t<span class="chg">c(PTR</span>2<span class="chg">CHAR</span>(reginput))<span class="chg">)</span>
</span><span class="nop"><span class="lno">4567 </span>		status = RA_NOMATCH;
<span class="lno">4568 </span>	    else
<span class="lno">4569 </span>		ADVANCE_REGINPUT();
</span><span class="nop"><span class="lno">4570 </span>	    break;
<span class="lno">4571 </span>
<span class="lno">4572 </span>	  case SPRINT:
</span><span class="upd"><span class="lno">4573 </span>	    if (VIM_ISDIGIT(*reginput) || <span class="chg">!vim_is</span>p<span class="chg">rin</span>t<span class="chg">c(PTR</span>2<span class="chg">CHAR</span>(reginput))<span class="chg">)</span>
</span><span class="nop"><span class="lno">4574 </span>		status = RA_NOMATCH;
<span class="lno">4575 </span>	    else
<span class="lno">4576 </span>		ADVANCE_REGINPUT();
</span></td></tr>
<tr><td class="ttd"><span class="lin">Line 4578 to 4586</span><span class="nop"><span class="lno">4578 </span>	  case BACKREF + 9:
<span class="lno">4579 </span>	    {
<span class="lno">4580 </span>		int		len;
</span><span class="del"><span class="lno">4581 </span>		linenr_T	clnum;
<span class="lno">4582 </span>		colnr_T		ccol;
<span class="lno">4583 </span>		char_u		*p;
</span><span class="nop"><span class="lno">4584 </span>
<span class="lno">4585 </span>		no = op - BACKREF;
<span class="lno">4586 </span>		cleanup_subexpr();
</span></td><td class="ttd"><span class="lin">Line 4980 to 4985</span><span class="nop"><span class="lno">4980 </span>	  case BACKREF + 9:
<span class="lno">4981 </span>	    {
<span class="lno">4982 </span>		int		len;
</span><span class="nop"><span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
</span><span class="nop"><span class="lno">4983 </span>
<span class="lno">4984 </span>		no = op - BACKREF;
<span class="lno">4985 </span>		cleanup_subexpr();
</span></td></tr>
<tr><td class="ttd"><span class="lin">Line 4622 to 4688</span><span class="nop"><span class="lno">4622 </span>			{
<span class="lno">4623 </span>			    /* Messy situation: Need to compare between two
<span class="lno">4624 </span>			     * lines. */
</span><span class="upd"><span class="lno">4625 </span>			    <span class="chg">ccol</span> = <span class="chg">reg</span>_<span class="chg">s</span>tar<span class="chg">tpos[no].col;</span>
<span class="lno">4626 </span>			   <span class="chg"> clnum =</span> reg_startpos[no].lnum<span class="chg">;</span>
<span class="lno">4627 </span>			    <span class="chg">f</span>o<span class="chg">r (;;)</span>
<span class="lno">4628 </span>			    <span class="chg">{</span>
<span class="lno">4629 </span>				<span class="chg">/*</span> <span class="chg">Sinc</span>e<span class="chg"> </span>ge<span class="chg">tti</span>n<span class="chg">g </span>on<span class="chg">e </span>l<span class="chg">ine may invalidate</span>
<span class="lno">4630 </span>				 <span class="chg">*</span> <span class="chg">the</span> <span class="chg">oth</span>e<span class="chg">r, </span>n<span class="chg">eed to make copy.  Slow! */</span>
</span><span class="del"><span class="lno">4631 </span>				if (regline != reg_tofree)
<span class="lno">4632 </span>				{
<span class="lno">4633 </span>				    len = (int)STRLEN(regline);
<span class="lno">4634 </span>				    if (reg_tofree == NULL
<span class="lno">4635 </span>						 || len &gt;= (int)reg_tofreelen)
<span class="lno">4636 </span>				    {
<span class="lno">4637 </span>					len += 50;	/* get some extra */
<span class="lno">4638 </span>					vim_free(reg_tofree);
<span class="lno">4639 </span>					reg_tofree = alloc(len);
<span class="lno">4640 </span>					if (reg_tofree == NULL)
<span class="lno">4641 </span>					{
<span class="lno">4642 </span>					    status = RA_FAIL; /* outof memory!*/
<span class="lno">4643 </span>					    break;
<span class="lno">4644 </span>					}
<span class="lno">4645 </span>					reg_tofreelen = len;
<span class="lno">4646 </span>				    }
<span class="lno">4647 </span>				    STRCPY(reg_tofree, regline);
<span class="lno">4648 </span>				    reginput = reg_tofree
<span class="lno">4649 </span>						       + (reginput - regline);
<span class="lno">4650 </span>				    regline = reg_tofree;
<span class="lno">4651 </span>				}
</span><span class="nop"><span class="lno">4652 </span>
</span><span class="upd"><span class="lno">4653 </span>			<span class="chg">	/*</span> <span class="chg">Get</span> <span class="chg">the</span> <span class="chg">l</span>i<span class="chg">ne</span> <span class="chg">to compa</span>r<span class="chg">e</span> <span class="chg">with.</span> <span class="chg">*/</span>
<span class="lno">4654 </span>				<span class="chg">p</span> = r<span class="chg">eg_getline(clnum)</span>;
</span><span class="del"><span class="lno">4655 </span>				if (clnum == reg_endpos[no].lnum)
<span class="lno">4656 </span>				    len = reg_endpos[no].col - ccol;
<span class="lno">4657 </span>				else
<span class="lno">4658 </span>				    len = (int)STRLEN(p + ccol);
<span class="lno">4659 </span>
<span class="lno">4660 </span>				if (cstrncmp(p + ccol, reginput, &amp;len) != 0)
<span class="lno">4661 </span>				{
<span class="lno">4662 </span>				    status = RA_NOMATCH;  /* doesn&#39;t match */
<span class="lno">4663 </span>				    break;
<span class="lno">4664 </span>				}
<span class="lno">4665 </span>				if (clnum == reg_endpos[no].lnum)
<span class="lno">4666 </span>				    break;		/* match and at end! */
<span class="lno">4667 </span>				if (reglnum &gt;= reg_maxline)
<span class="lno">4668 </span>				{
<span class="lno">4669 </span>				    status = RA_NOMATCH;  /* text too short */
<span class="lno">4670 </span>				    break;
<span class="lno">4671 </span>				}
<span class="lno">4672 </span>
<span class="lno">4673 </span>				/* Advance to next line. */
<span class="lno">4674 </span>				reg_nextline();
<span class="lno">4675 </span>				++clnum;
<span class="lno">4676 </span>				ccol = 0;
<span class="lno">4677 </span>				if (got_int)
<span class="lno">4678 </span>				{
<span class="lno">4679 </span>				    status = RA_FAIL;
<span class="lno">4680 </span>				    break;
<span class="lno">4681 </span>				}
<span class="lno">4682 </span>			    }
<span class="lno">4683 </span>
<span class="lno">4684 </span>			    /* found a match!  Note that regline may now point
<span class="lno">4685 </span>			     * to a copy of the line, that should not matter. */
</span><span class="nop"><span class="lno">4686 </span>			}
<span class="lno">4687 </span>		    }
<span class="lno">4688 </span>		}
</span></td><td class="ttd"><span class="lin">Line 5021 to 5035</span><span class="nop"><span class="lno">5021 </span>			{
<span class="lno">5022 </span>			    /* Messy situation: Need to compare between two
<span class="lno">5023 </span>			     * lines. */
</span><span class="upd"><span class="lno">5024 </span>			    <span class="chg">int r</span> = <span class="chg">match</span>_<span class="chg">wi</span>t<span class="chg">h_b</span>a<span class="chg">ck</span>r<span class="chg">ef(</span>
<span class="lno">5025 </span><span class="chg">		</span>			    reg_startpos[no].lnum<span class="chg">,</span>
<span class="lno">5026 </span><span class="chg">		</span>			    <span class="chg">reg_startpos[no].c</span>o<span class="chg">l,</span>
<span class="lno">5027 </span><span class="chg">		</span>			    <span class="chg">reg_endpos[no].lnum,</span>
<span class="lno">5028 </span>				<span class="chg">	   </span> <span class="chg">r</span>eg<span class="chg">_</span>en<span class="chg">dp</span>o<span class="chg">s[</span>n<span class="chg">o].co</span>l<span class="chg">,</span>
<span class="lno">5029 </span>				<span class="chg">	 </span>   <span class="chg">&amp;l</span>en<span class="chg">);</span>
</span><span class="nop"><span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
</span><span class="nop"><span class="lno">5030 </span>
</span><span class="upd"><span class="lno">5031 </span>			<span class="chg"> </span>   i<span class="chg">f</span> <span class="chg">(</span>r <span class="chg">!=</span> <span class="chg">RA_MATCH)</span>
<span class="lno">5032 </span>				<span class="chg">status</span> = r;
</span><span class="nop"><span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
</span><span class="nop"><span class="lno">5033 </span>			}
<span class="lno">5034 </span>		    }
<span class="lno">5035 </span>		}
</span></td></tr>
<tr><td class="ttd"><span class="lin">Line 5153 to 5159</span><span class="nop"><span class="lno">5153 </span>		/* save the position after the found match for next */
<span class="lno">5154 </span>		reg_save(&amp;(((regbehind_T *)rp) - 1)-&gt;save_after, &amp;backpos);
<span class="lno">5155 </span>
</span><span class="upd"><span class="lno">5156 </span>		/* <span class="chg">s</span>tart looking for a match with operand at the current
</span><span class="nop"><span class="lno">5157 </span>		 * position.  Go back one character until we find the
<span class="lno">5158 </span>		 * result, hitting the start of the line or the previous
<span class="lno">5159 </span>		 * line (for multi-line matching).
</span></td><td class="ttd"><span class="lin">Line 5500 to 5506</span><span class="nop"><span class="lno">5500 </span>		/* save the position after the found match for next */
<span class="lno">5501 </span>		reg_save(&amp;(((regbehind_T *)rp) - 1)-&gt;save_after, &amp;backpos);
<span class="lno">5502 </span>
</span><span class="upd"><span class="lno">5503 </span>		/* <span class="chg">S</span>tart looking for a match with operand at the current
</span><span class="nop"><span class="lno">5504 </span>		 * position.  Go back one character until we find the
<span class="lno">5505 </span>		 * result, hitting the start of the line or the previous
<span class="lno">5506 </span>		 * line (for multi-line matching).
</span></td></tr>
<tr><td class="ttd"><span class="lin">Line 5165 to 5171</span><span class="nop"><span class="lno">5165 </span>		rp-&gt;rs_state = RS_BEHIND2;
<span class="lno">5166 </span>
<span class="lno">5167 </span>		reg_restore(&amp;rp-&gt;rs_un.regsave, &amp;backpos);
</span><span class="upd"><span class="lno">5168 </span>		scan = OPERAND(rp-&gt;rs_scan);
</span><span class="nop"><span class="lno">5169 </span>	    }
<span class="lno">5170 </span>	    break;
<span class="lno">5171 </span>
</span></td><td class="ttd"><span class="lin">Line 5512 to 5518</span><span class="nop"><span class="lno">5512 </span>		rp-&gt;rs_state = RS_BEHIND2;
<span class="lno">5513 </span>
<span class="lno">5514 </span>		reg_restore(&amp;rp-&gt;rs_un.regsave, &amp;backpos);
</span><span class="upd"><span class="lno">5515 </span>		scan = OPERAND(rp-&gt;rs_scan)<span class="chg"> + 4</span>;
</span><span class="nop"><span class="lno">5516 </span>	    }
<span class="lno">5517 </span>	    break;
<span class="lno">5518 </span>
</span></td></tr>
<tr><td class="ttd"><span class="lin">Line 5193 to 5204</span><span class="nop"><span class="lno">5193 </span>	    }
<span class="lno">5194 </span>	    else
<span class="lno">5195 </span>	    {
</span><span class="nop"><span class="lno"> </span>
<span class="lno"> </span>
</span><span class="nop"><span class="lno">5196 </span>		/* No match or a match that doesn&#39;t end where we want it: Go
<span class="lno">5197 </span>		 * back one character.  May go to previous line once. */
<span class="lno">5198 </span>		no = OK;
</span><span class="nop"><span class="lno"> </span>
</span><span class="nop"><span class="lno">5199 </span>		if (REG_MULTI)
<span class="lno">5200 </span>		{
</span><span class="upd"><span class="lno">5201 </span>		    if (<span class="chg">rp-&gt;rs_un.regsave.rs_u.pos.co</span>l <span class="chg">==</span> 0<span class="chg">)</span>
</span><span class="nop"><span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
</span><span class="nop"><span class="lno">5202 </span>		    {
<span class="lno">5203 </span>			if (rp-&gt;rs_un.regsave.rs_u.pos.lnum
<span class="lno">5204 </span>					&lt; behind_pos.rs_u.pos.lnum
</span></td><td class="ttd"><span class="lin">Line 5540 to 5561</span><span class="nop"><span class="lno">5540 </span>	    }
<span class="lno">5541 </span>	    else
<span class="lno">5542 </span>	    {
</span><span class="add"><span class="lno">5543 </span>		long limit;
<span class="lno">5544 </span>
</span><span class="nop"><span class="lno">5545 </span>		/* No match or a match that doesn&#39;t end where we want it: Go
<span class="lno">5546 </span>		 * back one character.  May go to previous line once. */
<span class="lno">5547 </span>		no = OK;
</span><span class="add"><span class="lno">5548 </span>		limit = OPERAND_MIN(rp-&gt;rs_scan);
</span><span class="nop"><span class="lno">5549 </span>		if (REG_MULTI)
<span class="lno">5550 </span>		{
</span><span class="upd"><span class="lno">5551 </span>		    if (l<span class="chg">imit</span> <span class="chg">&gt;</span> 0
</span><span class="add"><span class="lno">5552 </span>			    &amp;&amp; ((rp-&gt;rs_un.regsave.rs_u.pos.lnum
<span class="lno">5553 </span>						    &lt; behind_pos.rs_u.pos.lnum
<span class="lno">5554 </span>				    ? (colnr_T)STRLEN(regline)
<span class="lno">5555 </span>				    : behind_pos.rs_u.pos.col)
<span class="lno">5556 </span>				- rp-&gt;rs_un.regsave.rs_u.pos.col &gt;= limit))
<span class="lno">5557 </span>			no = FAIL;
<span class="lno">5558 </span>		    else if (rp-&gt;rs_un.regsave.rs_u.pos.col == 0)
</span><span class="nop"><span class="lno">5559 </span>		    {
<span class="lno">5560 </span>			if (rp-&gt;rs_un.regsave.rs_u.pos.lnum
<span class="lno">5561 </span>					&lt; behind_pos.rs_u.pos.lnum
</span></td></tr>
<tr><td class="ttd"><span class="lin">Line 5214 to 5233</span><span class="nop"><span class="lno">5214 </span>			}
<span class="lno">5215 </span>		    }
<span class="lno">5216 </span>		    else
</span><span class="upd"><span class="lno">5217 </span>		<span class="chg">	--rp-&gt;rs_un.regsave.rs_u.pos.col;</span>
</span><span class="nop"><span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
</span><span class="nop"><span class="lno">5218 </span>		}
<span class="lno">5219 </span>		else
<span class="lno">5220 </span>		{
</span><span class="nop"><span class="lno">5221 </span>		    if (rp-&gt;rs_un.regsave.rs_u.ptr == regline)
<span class="lno">5222 </span>			no = FAIL;
<span class="lno">5223 </span>		    else
</span><span class="upd"><span class="lno">5224 </span>		<span class="chg">	--rp-&gt;rs_un.regsave.rs_u.ptr;</span>
</span><span class="nop"><span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
</span><span class="nop"><span class="lno">5225 </span>		}
<span class="lno">5226 </span>		if (no == OK)
<span class="lno">5227 </span>		{
</span><span class="nop"><span class="lno">5228 </span>		    /* Advanced, prepare for finding match again. */
<span class="lno">5229 </span>		    reg_restore(&amp;rp-&gt;rs_un.regsave, &amp;backpos);
</span><span class="upd"><span class="lno">5230 </span>		    scan = OPERAND(rp-&gt;rs_scan);
</span><span class="nop"><span class="lno">5231 </span>		    if (status == RA_MATCH)
<span class="lno">5232 </span>		    {
<span class="lno">5233 </span>			/* We did match, so subexpr may have been changed,
</span></td><td class="ttd"><span class="lin">Line 5571 to 5604</span><span class="nop"><span class="lno">5571 </span>			}
<span class="lno">5572 </span>		    }
<span class="lno">5573 </span>		    else
</span><span class="upd"><span class="lno">5574 </span>		<span class="chg">    {</span>
</span><span class="add"><span class="lno">5575 </span>#ifdef FEAT_MBYTE
<span class="lno">5576 </span>			if (has_mbyte)
<span class="lno">5577 </span>			    rp-&gt;rs_un.regsave.rs_u.pos.col -=
<span class="lno">5578 </span>				(*mb_head_off)(regline, regline
<span class="lno">5579 </span>				    + rp-&gt;rs_un.regsave.rs_u.pos.col - 1) + 1;
<span class="lno">5580 </span>			else
<span class="lno">5581 </span>#endif
<span class="lno">5582 </span>			    --rp-&gt;rs_un.regsave.rs_u.pos.col;
<span class="lno">5583 </span>		    }
</span><span class="nop"><span class="lno">5584 </span>		}
<span class="lno">5585 </span>		else
<span class="lno">5586 </span>		{
</span><span class="nop"><span class="lno">5587 </span>		    if (rp-&gt;rs_un.regsave.rs_u.ptr == regline)
<span class="lno">5588 </span>			no = FAIL;
<span class="lno">5589 </span>		    else
</span><span class="upd"><span class="lno">5590 </span>		<span class="chg">    {</span>
</span><span class="add"><span class="lno">5591 </span>			mb_ptr_back(regline, rp-&gt;rs_un.regsave.rs_u.ptr);
<span class="lno">5592 </span>			if (limit &gt; 0 &amp;&amp; (long)(behind_pos.rs_u.ptr
<span class="lno">5593 </span>				     - rp-&gt;rs_un.regsave.rs_u.ptr) &gt; limit)
<span class="lno">5594 </span>			    no = FAIL;
<span class="lno">5595 </span>		    }
</span><span class="nop"><span class="lno">5596 </span>		}
<span class="lno">5597 </span>		if (no == OK)
<span class="lno">5598 </span>		{
</span><span class="nop"><span class="lno">5599 </span>		    /* Advanced, prepare for finding match again. */
<span class="lno">5600 </span>		    reg_restore(&amp;rp-&gt;rs_un.regsave, &amp;backpos);
</span><span class="upd"><span class="lno">5601 </span>		    scan = OPERAND(rp-&gt;rs_scan)<span class="chg"> + 4</span>;
</span><span class="nop"><span class="lno">5602 </span>		    if (status == RA_MATCH)
<span class="lno">5603 </span>		    {
<span class="lno">5604 </span>			/* We did match, so subexpr may have been changed,
</span></td></tr>
<tr><td class="ttd"><span class="lin">Line 5472 to 5478</span><span class="nop"><span class="lno">5472 </span>      case SIDENT + ADD_NL:
<span class="lno">5473 </span>	while (count &lt; maxcount)
<span class="lno">5474 </span>	{
</span><span class="upd"><span class="lno">5475 </span>	    if (vim_isIDc(<span class="chg">*</span>scan) &amp;&amp; (testval || !VIM_ISDIGIT(*scan)))
</span><span class="nop"><span class="lno">5476 </span>	    {
<span class="lno">5477 </span>		mb_ptr_adv(scan);
<span class="lno">5478 </span>	    }
</span></td><td class="ttd"><span class="lin">Line 5843 to 5849</span><span class="nop"><span class="lno">5843 </span>      case SIDENT + ADD_NL:
<span class="lno">5844 </span>	while (count &lt; maxcount)
<span class="lno">5845 </span>	{
</span><span class="upd"><span class="lno">5846 </span>	    if (vim_isIDc(<span class="chg">PTR2CHAR(</span>scan<span class="chg">)</span>) &amp;&amp; (testval || !VIM_ISDIGIT(*scan)))
</span><span class="nop"><span class="lno">5847 </span>	    {
<span class="lno">5848 </span>		mb_ptr_adv(scan);
<span class="lno">5849 </span>	    }
</span></td></tr>
<tr><td class="ttd"><span class="lin">Line 5502 to 5508</span><span class="nop"><span class="lno">5502 </span>      case SKWORD + ADD_NL:
<span class="lno">5503 </span>	while (count &lt; maxcount)
<span class="lno">5504 </span>	{
</span><span class="upd"><span class="lno">5505 </span>	    if (vim_iswordp(scan<span class="chg">)</span> <span class="chg">&amp;&amp; (t</span>e<span class="chg">stval || !VIM</span>_<span class="chg">ISDIGIT(*scan))</span>)
</span><span class="nop"><span class="lno"> </span>
</span><span class="nop"><span class="lno">5506 </span>	    {
<span class="lno">5507 </span>		mb_ptr_adv(scan);
<span class="lno">5508 </span>	    }
</span></td><td class="ttd"><span class="lin">Line 5873 to 5880</span><span class="nop"><span class="lno">5873 </span>      case SKWORD + ADD_NL:
<span class="lno">5874 </span>	while (count &lt; maxcount)
<span class="lno">5875 </span>	{
</span><span class="upd"><span class="lno">5876 </span>	    if (vim_iswordp<span class="chg">_buf</span>(scan<span class="chg">,</span> <span class="chg">r</span>e<span class="chg">g</span>_<span class="chg">buf</span>)
</span><span class="add"><span class="lno">5877 </span>					  &amp;&amp; (testval || !VIM_ISDIGIT(*scan)))
</span><span class="nop"><span class="lno">5878 </span>	    {
<span class="lno">5879 </span>		mb_ptr_adv(scan);
<span class="lno">5880 </span>	    }
</span></td></tr>
<tr><td class="ttd"><span class="lin">Line 5532 to 5538</span><span class="nop"><span class="lno">5532 </span>      case SFNAME + ADD_NL:
<span class="lno">5533 </span>	while (count &lt; maxcount)
<span class="lno">5534 </span>	{
</span><span class="upd"><span class="lno">5535 </span>	    if (vim_isfilec(<span class="chg">*</span>scan) &amp;&amp; (testval || !VIM_ISDIGIT(*scan)))
</span><span class="nop"><span class="lno">5536 </span>	    {
<span class="lno">5537 </span>		mb_ptr_adv(scan);
<span class="lno">5538 </span>	    }
</span></td><td class="ttd"><span class="lin">Line 5904 to 5910</span><span class="nop"><span class="lno">5904 </span>      case SFNAME + ADD_NL:
<span class="lno">5905 </span>	while (count &lt; maxcount)
<span class="lno">5906 </span>	{
</span><span class="upd"><span class="lno">5907 </span>	    if (vim_isfilec(<span class="chg">PTR2CHAR(</span>scan<span class="chg">)</span>) &amp;&amp; (testval || !VIM_ISDIGIT(*scan)))
</span><span class="nop"><span class="lno">5908 </span>	    {
<span class="lno">5909 </span>		mb_ptr_adv(scan);
<span class="lno">5910 </span>	    }
</span></td></tr>
<tr><td class="ttd"><span class="lin">Line 5572 to 5578</span><span class="nop"><span class="lno">5572 </span>		if (got_int)
<span class="lno">5573 </span>		    break;
<span class="lno">5574 </span>	    }
</span><span class="upd"><span class="lno">5575 </span>	    else if (pt<span class="chg">r</span>2<span class="chg">cells</span>(scan) == 1<span class="chg"> &amp;&amp; (testval || !VIM_ISDIGIT(*scan)))</span>
</span><span class="nop"><span class="lno"> </span>
</span><span class="nop"><span class="lno">5576 </span>	    {
<span class="lno">5577 </span>		mb_ptr_adv(scan);
<span class="lno">5578 </span>	    }
</span></td><td class="ttd"><span class="lin">Line 5944 to 5951</span><span class="nop"><span class="lno">5944 </span>		if (got_int)
<span class="lno">5945 </span>		    break;
<span class="lno">5946 </span>	    }
</span><span class="upd"><span class="lno">5947 </span>	    else if (<span class="chg">vim_is</span>p<span class="chg">rin</span>t<span class="chg">c(PTR</span>2<span class="chg">CHAR</span>(scan)<span class="chg">)</span> == 1
</span><span class="add"><span class="lno">5948 </span>					  &amp;&amp; (testval || !VIM_ISDIGIT(*scan)))
</span><span class="nop"><span class="lno">5949 </span>	    {
<span class="lno">5950 </span>		mb_ptr_adv(scan);
<span class="lno">5951 </span>	    }
</span></td></tr>
<tr><td class="ttd"><span class="lin">Line 5848 to 5856</span><span class="nop"><span class="lno">5848 </span>    static int
<span class="lno">5849 </span>prog_magic_wrong()
<span class="lno">5850 </span>{
</span><span class="upd"><span class="lno">5851 </span>    <span class="chg">if (UCHARAT(REG</span>_<span class="chg">MUL</span>T<span class="chg">I</span>
<span class="lno">5852 </span><span class="chg">		? reg_mmatch-&gt;regprog-&gt;program</span>
<span class="lno">5853 </span><span class="chg">		:</span> reg_match-&gt;regprog-&gt;prog<span class="chg">ram) != REGMAGIC)</span>
</span><span class="nop"><span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
</span><span class="nop"><span class="lno">5854 </span>    {
<span class="lno">5855 </span>	EMSG(_(e_re_corr));
<span class="lno">5856 </span>	return TRUE;
</span></td><td class="ttd"><span class="lin">Line 6221 to 6234</span><span class="nop"><span class="lno">6221 </span>    static int
<span class="lno">6222 </span>prog_magic_wrong()
<span class="lno">6223 </span>{
</span><span class="upd"><span class="lno">6224 </span>    <span class="chg">regprog</span>_T<span class="chg">	*prog;</span>
<span class="lno">6225 </span>
<span class="lno">6226 </span><span class="chg">    prog = REG_MULTI ?</span> reg_m<span class="chg">m</span>atch-&gt;regprog<span class="chg"> : reg_match</span>-&gt;<span class="chg">reg</span>prog<span class="chg">;</span>
</span><span class="add"><span class="lno">6227 </span>    if (prog-&gt;engine == &amp;nfa_regengine)
<span class="lno">6228 </span>	/* For NFA matcher we don&#39;t check the magic */
<span class="lno">6229 </span>	return FALSE;
<span class="lno">6230 </span>
<span class="lno">6231 </span>    if (UCHARAT(((bt_regprog_T *)prog)-&gt;program) != REGMAGIC)
</span><span class="nop"><span class="lno">6232 </span>    {
<span class="lno">6233 </span>	EMSG(_(e_re_corr));
<span class="lno">6234 </span>	return TRUE;
</span></td></tr>
<tr><td class="ttd"><span class="lin">Line 6074 to 6081</span><span class="nop"><span class="lno">6074 </span>    return val == n;
<span class="lno">6075 </span>}
<span class="lno">6076 </span>
</span><span class="nop"><span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
</span><span class="nop"><span class="lno">6077 </span>
</span><span class="upd"><span class="lno">6078 </span><span class="chg">#</span>if<span class="chg">d</span>e<span class="chg">f</span> <span class="chg">DEBUG</span>
</span><span class="nop"><span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
</span><span class="nop"><span class="lno">6079 </span>
<span class="lno">6080 </span>/*
<span class="lno">6081 </span> * regdump - dump a regexp onto stdout in vaguely comprehensible form
</span></td><td class="ttd"><span class="lin">Line 6452 to 6528</span><span class="nop"><span class="lno">6452 </span>    return val == n;
<span class="lno">6453 </span>}
<span class="lno">6454 </span>
</span><span class="add"><span class="lno">6455 </span>/*
<span class="lno">6456 </span> * Check whether a backreference matches.
<span class="lno">6457 </span> * Returns RA_FAIL, RA_NOMATCH or RA_MATCH.
<span class="lno">6458 </span> * If &#34;bytelen&#34; is not NULL, it is set to the bytelength of the whole match.
<span class="lno">6459 </span> */
<span class="lno">6460 </span>    static int
<span class="lno">6461 </span>match_with_backref(start_lnum, start_col, end_lnum, end_col, bytelen)
<span class="lno">6462 </span>    linenr_T start_lnum;
<span class="lno">6463 </span>    colnr_T  start_col;
<span class="lno">6464 </span>    linenr_T end_lnum;
<span class="lno">6465 </span>    colnr_T  end_col;
<span class="lno">6466 </span>    int	     *bytelen;
<span class="lno">6467 </span>{
<span class="lno">6468 </span>    linenr_T	clnum = start_lnum;
<span class="lno">6469 </span>    colnr_T	ccol = start_col;
<span class="lno">6470 </span>    int		len;
<span class="lno">6471 </span>    char_u	*p;
<span class="lno">6472 </span>
<span class="lno">6473 </span>    if (bytelen != NULL)
<span class="lno">6474 </span>	*bytelen = 0;
<span class="lno">6475 </span>    for (;;)
<span class="lno">6476 </span>    {
<span class="lno">6477 </span>	/* Since getting one line may invalidate the other, need to make copy.
<span class="lno">6478 </span>	 * Slow! */
<span class="lno">6479 </span>	if (regline != reg_tofree)
<span class="lno">6480 </span>	{
<span class="lno">6481 </span>	    len = (int)STRLEN(regline);
<span class="lno">6482 </span>	    if (reg_tofree == NULL || len &gt;= (int)reg_tofreelen)
<span class="lno">6483 </span>	    {
<span class="lno">6484 </span>		len += 50;	/* get some extra */
<span class="lno">6485 </span>		vim_free(reg_tofree);
<span class="lno">6486 </span>		reg_tofree = alloc(len);
<span class="lno">6487 </span>		if (reg_tofree == NULL)
<span class="lno">6488 </span>		    return RA_FAIL; /* out of memory!*/
<span class="lno">6489 </span>		reg_tofreelen = len;
<span class="lno">6490 </span>	    }
<span class="lno">6491 </span>	    STRCPY(reg_tofree, regline);
<span class="lno">6492 </span>	    reginput = reg_tofree + (reginput - regline);
<span class="lno">6493 </span>	    regline = reg_tofree;
<span class="lno">6494 </span>	}
<span class="lno">6495 </span>
<span class="lno">6496 </span>	/* Get the line to compare with. */
<span class="lno">6497 </span>	p = reg_getline(clnum);
<span class="lno">6498 </span>	if (clnum == end_lnum)
<span class="lno">6499 </span>	    len = end_col - ccol;
<span class="lno">6500 </span>	else
<span class="lno">6501 </span>	    len = (int)STRLEN(p + ccol);
</span><span class="nop"><span class="lno">6502 </span>
</span><span class="upd"><span class="lno">6503 </span><span class="chg">	</span>if<span class="chg"> (cstrncmp(p + ccol, reginput, &amp;l</span>e<span class="chg">n) !=</span> <span class="chg">0)</span>
</span><span class="add"><span class="lno">6504 </span>	    return RA_NOMATCH;  /* doesn&#39;t match */
<span class="lno">6505 </span>	if (bytelen != NULL)
<span class="lno">6506 </span>	    *bytelen += len;
<span class="lno">6507 </span>	if (clnum == end_lnum)
<span class="lno">6508 </span>	    break;		/* match and at end! */
<span class="lno">6509 </span>	if (reglnum &gt;= reg_maxline)
<span class="lno">6510 </span>	    return RA_NOMATCH;  /* text too short */
<span class="lno">6511 </span>
<span class="lno">6512 </span>	/* Advance to next line. */
<span class="lno">6513 </span>	reg_nextline();
<span class="lno">6514 </span>	++clnum;
<span class="lno">6515 </span>	ccol = 0;
<span class="lno">6516 </span>	if (got_int)
<span class="lno">6517 </span>	    return RA_FAIL;
<span class="lno">6518 </span>    }
<span class="lno">6519 </span>
<span class="lno">6520 </span>    /* found a match!  Note that regline may now point to a copy of the line,
<span class="lno">6521 </span>     * that should not matter. */
<span class="lno">6522 </span>    return RA_MATCH;
<span class="lno">6523 </span>}
<span class="lno">6524 </span>
<span class="lno">6525 </span>#ifdef BT_REGEXP_DUMP
</span><span class="nop"><span class="lno">6526 </span>
<span class="lno">6527 </span>/*
<span class="lno">6528 </span> * regdump - dump a regexp onto stdout in vaguely comprehensible form
</span></td></tr>
<tr><td class="ttd"><span class="lin">Line 6083 to 6096</span><span class="nop"><span class="lno">6083 </span>    static void
<span class="lno">6084 </span>regdump(pattern, r)
<span class="lno">6085 </span>    char_u	*pattern;
</span><span class="upd"><span class="lno">6086 </span>    regprog_T	*r;
</span><span class="nop"><span class="lno">6087 </span>{
<span class="lno">6088 </span>    char_u  *s;
<span class="lno">6089 </span>    int	    op = EXACTLY;	/* Arbitrary non-END op. */
</span><span class="nop"><span class="lno">6090 </span>    char_u  *next;
<span class="lno">6091 </span>    char_u  *end = NULL;
</span><span class="nop"><span class="lno"> </span>
</span><span class="nop"><span class="lno">6092 </span>
</span><span class="upd"><span class="lno">6093 </span><span class="chg">    pr</span>i<span class="chg">nt</span>f<span class="chg">(&#34;\r\nr</span>e<span class="chg">gcomp(%s):\r\n&#34;,</span> <span class="chg">pattern);</span>
</span><span class="nop"><span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
</span><span class="nop"><span class="lno">6094 </span>
<span class="lno">6095 </span>    s = r-&gt;program + 1;
<span class="lno">6096 </span>    /*
</span></td><td class="ttd"><span class="lin">Line 6530 to 6551</span><span class="nop"><span class="lno">6530 </span>    static void
<span class="lno">6531 </span>regdump(pattern, r)
<span class="lno">6532 </span>    char_u	*pattern;
</span><span class="upd"><span class="lno">6533 </span>    <span class="chg">bt_</span>regprog_T	*r;
</span><span class="nop"><span class="lno">6534 </span>{
<span class="lno">6535 </span>    char_u  *s;
<span class="lno">6536 </span>    int	    op = EXACTLY;	/* Arbitrary non-END op. */
</span><span class="nop"><span class="lno">6537 </span>    char_u  *next;
<span class="lno">6538 </span>    char_u  *end = NULL;
</span><span class="add"><span class="lno">6539 </span>    FILE    *f;
</span><span class="nop"><span class="lno">6540 </span>
</span><span class="upd"><span class="lno">6541 </span><span class="chg">#</span>if<span class="chg">d</span>e<span class="chg">f</span> <span class="chg">BT_REGEXP_LOG</span>
</span><span class="add"><span class="lno">6542 </span>    f = fopen(&#34;bt_regexp_log.log&#34;, &#34;a&#34;);
<span class="lno">6543 </span>#else
<span class="lno">6544 </span>    f = stdout;
<span class="lno">6545 </span>#endif
<span class="lno">6546 </span>    if (f == NULL)
<span class="lno">6547 </span>	return;
<span class="lno">6548 </span>    fprintf(f, &#34;-------------------------------------\n\r\nregcomp(%s):\r\n&#34;, pattern);
</span><span class="nop"><span class="lno">6549 </span>
<span class="lno">6550 </span>    s = r-&gt;program + 1;
<span class="lno">6551 </span>    /*
</span></td></tr>
<tr><td class="ttd"><span class="lin">Line 6100 to 6144</span><span class="nop"><span class="lno">6100 </span>    while (op != END || s &lt;= end)
<span class="lno">6101 </span>    {
<span class="lno">6102 </span>	op = OP(s);
</span><span class="upd"><span class="lno">6103 </span>	printf(&#34;%2d%s&#34;, (int)(s - r-&gt;program), regprop(s)); /* Where, what. */
</span><span class="nop"><span class="lno">6104 </span>	next = regnext(s);
<span class="lno">6105 </span>	if (next == NULL)	/* Next ptr. */
</span><span class="upd"><span class="lno">6106 </span>	    printf(&#34;(0)&#34;);
</span><span class="nop"><span class="lno">6107 </span>	else
</span><span class="upd"><span class="lno">6108 </span>	    printf(&#34;(%d)&#34;, (int)((s - r-&gt;program) + (next - s)));
</span><span class="nop"><span class="lno">6109 </span>	if (end &lt; next)
<span class="lno">6110 </span>	    end = next;
<span class="lno">6111 </span>	if (op == BRACE_LIMITS)
</span><span class="nop"><span class="lno">6112 </span>	{
</span><span class="upd"><span class="lno">6113 </span>	    /* Two <span class="chg">short </span>ints */
<span class="lno">6114 </span>	    printf(&#34; minval %ld, maxval %ld&#34;, OPERAND_MIN(s), OPERAND_MAX(s));
</span><span class="nop"><span class="lno">6115 </span>	    s += 8;
<span class="lno">6116 </span>	}
</span><span class="nop"><span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
</span><span class="nop"><span class="lno">6117 </span>	s += 3;
<span class="lno">6118 </span>	if (op == ANYOF || op == ANYOF + ADD_NL
<span class="lno">6119 </span>		|| op == ANYBUT || op == ANYBUT + ADD_NL
</span><span class="nop"><span class="lno">6120 </span>		|| op == EXACTLY)
<span class="lno">6121 </span>	{
<span class="lno">6122 </span>	    /* Literal string, where present. */
</span><span class="nop"><span class="lno"> </span>
</span><span class="nop"><span class="lno">6123 </span>	    while (*s != NUL)
</span><span class="upd"><span class="lno">6124 </span>		printf(&#34;%c&#34;, *s++);
</span><span class="nop"><span class="lno"> </span>
</span><span class="nop"><span class="lno">6125 </span>	    s++;
<span class="lno">6126 </span>	}
</span><span class="upd"><span class="lno">6127 </span>	printf(&#34;\r\n&#34;);
</span><span class="nop"><span class="lno">6128 </span>    }
<span class="lno">6129 </span>
<span class="lno">6130 </span>    /* Header fields of interest. */
</span><span class="nop"><span class="lno">6131 </span>    if (r-&gt;regstart != NUL)
</span><span class="upd"><span class="lno">6132 </span>	printf(&#34;start `%s&#39; 0x%x; &#34;, r-&gt;regstart &lt; 256
</span><span class="nop"><span class="lno">6133 </span>		? (char *)transchar(r-&gt;regstart)
<span class="lno">6134 </span>		: &#34;multibyte&#34;, r-&gt;regstart);
<span class="lno">6135 </span>    if (r-&gt;reganch)
</span><span class="upd"><span class="lno">6136 </span>	printf(&#34;anchored; &#34;);
</span><span class="nop"><span class="lno">6137 </span>    if (r-&gt;regmust != NULL)
</span><span class="upd"><span class="lno">6138 </span>	printf(&#34;must have \&#34;%s\&#34;&#34;, r-&gt;regmust);
<span class="lno">6139 </span>    printf(&#34;\r\n&#34;);
</span><span class="nop"><span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
</span><span class="nop"><span class="lno">6140 </span>}
</span><span class="nop"><span class="lno"> </span>
</span><span class="nop"><span class="lno">6141 </span>
</span><span class="nop"><span class="lno"> </span>
</span><span class="nop"><span class="lno">6142 </span>/*
<span class="lno">6143 </span> * regprop - printable representation of opcode
<span class="lno">6144 </span> */
</span></td><td class="ttd"><span class="lin">Line 6555 to 6619</span><span class="nop"><span class="lno">6555 </span>    while (op != END || s &lt;= end)
<span class="lno">6556 </span>    {
<span class="lno">6557 </span>	op = OP(s);
</span><span class="upd"><span class="lno">6558 </span>	<span class="chg">f</span>printf(<span class="chg">f, </span>&#34;%2d%s&#34;, (int)(s - r-&gt;program), regprop(s)); /* Where, what. */
</span><span class="nop"><span class="lno">6559 </span>	next = regnext(s);
<span class="lno">6560 </span>	if (next == NULL)	/* Next ptr. */
</span><span class="upd"><span class="lno">6561 </span>	    <span class="chg">f</span>printf(<span class="chg">f, </span>&#34;(0)&#34;);
</span><span class="nop"><span class="lno">6562 </span>	else
</span><span class="upd"><span class="lno">6563 </span>	    <span class="chg">f</span>printf(<span class="chg">f, </span>&#34;(%d)&#34;, (int)((s - r-&gt;program) + (next - s)));
</span><span class="nop"><span class="lno">6564 </span>	if (end &lt; next)
<span class="lno">6565 </span>	    end = next;
<span class="lno">6566 </span>	if (op == BRACE_LIMITS)
</span><span class="nop"><span class="lno">6567 </span>	{
</span><span class="upd"><span class="lno">6568 </span>	    /* Two ints */
<span class="lno">6569 </span>	    <span class="chg">f</span>printf(<span class="chg">f, </span>&#34; minval %ld, maxval %ld&#34;, OPERAND_MIN(s), OPERAND_MAX(s));
</span><span class="nop"><span class="lno">6570 </span>	    s += 8;
<span class="lno">6571 </span>	}
</span><span class="add"><span class="lno">6572 </span>	else if (op == BEHIND || op == NOBEHIND)
<span class="lno">6573 </span>	{
<span class="lno">6574 </span>	    /* one int */
<span class="lno">6575 </span>	    fprintf(f, &#34; count %ld&#34;, OPERAND_MIN(s));
<span class="lno">6576 </span>	    s += 4;
<span class="lno">6577 </span>	}
<span class="lno">6578 </span>	else if (op == RE_LNUM || op == RE_COL || op == RE_VCOL)
<span class="lno">6579 </span>	{
<span class="lno">6580 </span>	    /* one int plus comperator */
<span class="lno">6581 </span>	    fprintf(f, &#34; count %ld&#34;, OPERAND_MIN(s));
<span class="lno">6582 </span>	    s += 5;
<span class="lno">6583 </span>	}
</span><span class="nop"><span class="lno">6584 </span>	s += 3;
<span class="lno">6585 </span>	if (op == ANYOF || op == ANYOF + ADD_NL
<span class="lno">6586 </span>		|| op == ANYBUT || op == ANYBUT + ADD_NL
</span><span class="nop"><span class="lno">6587 </span>		|| op == EXACTLY)
<span class="lno">6588 </span>	{
<span class="lno">6589 </span>	    /* Literal string, where present. */
</span><span class="add"><span class="lno">6590 </span>	    fprintf(f, &#34;\nxxxxxxxxx\n&#34;);
</span><span class="nop"><span class="lno">6591 </span>	    while (*s != NUL)
</span><span class="upd"><span class="lno">6592 </span>		<span class="chg">f</span>printf(<span class="chg">f, </span>&#34;%c&#34;, *s++);
</span><span class="add"><span class="lno">6593 </span>	    fprintf(f, &#34;\nxxxxxxxxx\n&#34;);
</span><span class="nop"><span class="lno">6594 </span>	    s++;
<span class="lno">6595 </span>	}
</span><span class="upd"><span class="lno">6596 </span>	<span class="chg">f</span>printf(<span class="chg">f, </span>&#34;\r\n&#34;);
</span><span class="nop"><span class="lno">6597 </span>    }
<span class="lno">6598 </span>
<span class="lno">6599 </span>    /* Header fields of interest. */
</span><span class="nop"><span class="lno">6600 </span>    if (r-&gt;regstart != NUL)
</span><span class="upd"><span class="lno">6601 </span>	<span class="chg">f</span>printf(<span class="chg">f, </span>&#34;start `%s&#39; 0x%x; &#34;, r-&gt;regstart &lt; 256
</span><span class="nop"><span class="lno">6602 </span>		? (char *)transchar(r-&gt;regstart)
<span class="lno">6603 </span>		: &#34;multibyte&#34;, r-&gt;regstart);
<span class="lno">6604 </span>    if (r-&gt;reganch)
</span><span class="upd"><span class="lno">6605 </span>	<span class="chg">f</span>printf(<span class="chg">f, </span>&#34;anchored; &#34;);
</span><span class="nop"><span class="lno">6606 </span>    if (r-&gt;regmust != NULL)
</span><span class="upd"><span class="lno">6607 </span>	<span class="chg">f</span>printf(<span class="chg">f, </span>&#34;must have \&#34;%s\&#34;&#34;, r-&gt;regmust);
<span class="lno">6608 </span>    <span class="chg">f</span>printf(<span class="chg">f, </span>&#34;\r\n&#34;);
</span><span class="add"><span class="lno">6609 </span>
<span class="lno">6610 </span>#ifdef BT_REGEXP_LOG
<span class="lno">6611 </span>    fclose(f);
<span class="lno">6612 </span>#endif
</span><span class="nop"><span class="lno">6613 </span>}
</span><span class="add"><span class="lno">6614 </span>#endif	    /* BT_REGEXP_DUMP */
</span><span class="nop"><span class="lno">6615 </span>
</span><span class="add"><span class="lno">6616 </span>#ifdef DEBUG
</span><span class="nop"><span class="lno">6617 </span>/*
<span class="lno">6618 </span> * regprop - printable representation of opcode
<span class="lno">6619 </span> */
</span></td></tr>
<tr><td class="ttd"><span class="lin">Line 6146 to 6157</span><span class="nop"><span class="lno">6146 </span>regprop(op)
<span class="lno">6147 </span>    char_u	   *op;
<span class="lno">6148 </span>{
</span><span class="upd"><span class="lno">6149 </span>    char<span class="chg">_u</span>	    *p;
<span class="lno">6150 </span>    static char<span class="chg">_u</span>   buf[50];
</span><span class="nop"><span class="lno">6151 </span>
</span><span class="upd"><span class="lno">6152 </span>    <span class="chg">(void) strcpy</span>(buf, &#34;:&#34;);
</span><span class="nop"><span class="lno">6153 </span>
</span><span class="upd"><span class="lno">6154 </span>    switch (OP(op))
</span><span class="nop"><span class="lno">6155 </span>    {
<span class="lno">6156 </span>      case BOL:
<span class="lno">6157 </span>	p = &#34;BOL&#34;;
</span></td><td class="ttd"><span class="lin">Line 6621 to 6632</span><span class="nop"><span class="lno">6621 </span>regprop(op)
<span class="lno">6622 </span>    char_u	   *op;
<span class="lno">6623 </span>{
</span><span class="upd"><span class="lno">6624 </span>    char	    *p;
<span class="lno">6625 </span>    static char<span class="chg">	 </span>   buf[50];
</span><span class="nop"><span class="lno">6626 </span>
</span><span class="upd"><span class="lno">6627 </span>    <span class="chg">STRCPY</span>(buf, &#34;:&#34;);
</span><span class="nop"><span class="lno">6628 </span>
</span><span class="upd"><span class="lno">6629 </span>    switch (<span class="chg">(int) </span>OP(op))
</span><span class="nop"><span class="lno">6630 </span>    {
<span class="lno">6631 </span>      case BOL:
<span class="lno">6632 </span>	p = &#34;BOL&#34;;
</span></td></tr>
<tr><td class="ttd"><span class="lin">Line 6518 to 6527</span><span class="nop"><span class="lno">6518 </span>	break;
<span class="lno">6519 </span>    }
<span class="lno">6520 </span>    if (p != NULL)
</span><span class="upd"><span class="lno">6521 </span>	<span class="chg">(void) strcat</span>(buf, p);
<span class="lno">6522 </span>    return buf;
</span><span class="nop"><span class="lno">6523 </span>}
</span><span class="upd"><span class="lno">6524 </span>#endif
</span><span class="nop"><span class="lno">6525 </span>
<span class="lno">6526 </span>#ifdef FEAT_MBYTE
<span class="lno">6527 </span>static void mb_decompose __ARGS((int c, int *c1, int *c2, int *c3));
</span></td><td class="ttd"><span class="lin">Line 6993 to 7002</span><span class="nop"><span class="lno">6993 </span>	break;
<span class="lno">6994 </span>    }
<span class="lno">6995 </span>    if (p != NULL)
</span><span class="upd"><span class="lno">6996 </span>	<span class="chg">STRCAT</span>(buf, p);
<span class="lno">6997 </span>    return <span class="chg">(char_u *)</span>buf;
</span><span class="nop"><span class="lno">6998 </span>}
</span><span class="upd"><span class="lno">6999 </span>#endif<span class="chg">	    /* DEBUG */</span>
</span><span class="nop"><span class="lno">7000 </span>
<span class="lno">7001 </span>#ifdef FEAT_MBYTE
<span class="lno">7002 </span>static void mb_decompose __ARGS((int c, int *c1, int *c2, int *c3));
</span></td></tr>
<tr><td class="ttd"><span class="lin">Line 6591 to 6597</span><span class="nop"><span class="lno">6591 </span>{
<span class="lno">6592 </span>    decomp_T d;
<span class="lno">6593 </span>
</span><span class="upd"><span class="lno">6594 </span>    if (c &gt;= 0x<span class="chg">4</span>b20 &amp;&amp; c &lt;= 0xfb4f)
</span><span class="nop"><span class="lno">6595 </span>    {
<span class="lno">6596 </span>	d = decomp_table[c - 0xfb20];
<span class="lno">6597 </span>	*c1 = d.a;
</span></td><td class="ttd"><span class="lin">Line 7066 to 7072</span><span class="nop"><span class="lno">7066 </span>{
<span class="lno">7067 </span>    decomp_T d;
<span class="lno">7068 </span>
</span><span class="upd"><span class="lno">7069 </span>    if (c &gt;= 0x<span class="chg">f</span>b20 &amp;&amp; c &lt;= 0xfb4f)
</span><span class="nop"><span class="lno">7070 </span>    {
<span class="lno">7071 </span>	d = decomp_table[c - 0xfb20];
<span class="lno">7072 </span>	*c1 = d.a;
</span></td></tr>
<tr><td class="ttd"><span class="lin">Line 6871 to 6876</span><span class="nop"><span class="lno">6871 </span>static regmmatch_T	*submatch_mmatch;
<span class="lno">6872 </span>static linenr_T		submatch_firstlnum;
<span class="lno">6873 </span>static linenr_T		submatch_maxline;
</span><span class="nop"><span class="lno"> </span>
</span><span class="nop"><span class="lno">6874 </span>#endif
<span class="lno">6875 </span>
<span class="lno">6876 </span>#if defined(FEAT_MODIFY_FNAME) || defined(FEAT_EVAL) || defined(PROTO)
</span></td><td class="ttd"><span class="lin">Line 7346 to 7352</span><span class="nop"><span class="lno">7346 </span>static regmmatch_T	*submatch_mmatch;
<span class="lno">7347 </span>static linenr_T		submatch_firstlnum;
<span class="lno">7348 </span>static linenr_T		submatch_maxline;
</span><span class="add"><span class="lno">7349 </span>static int		submatch_line_lbr;
</span><span class="nop"><span class="lno">7350 </span>#endif
<span class="lno">7351 </span>
<span class="lno">7352 </span>#if defined(FEAT_MODIFY_FNAME) || defined(FEAT_EVAL) || defined(PROTO)
</span></td></tr>
<tr><td class="ttd"><span class="lin">Line 6904 to 6909</span><span class="nop"><span class="lno">6904 </span>    reg_match = rmp;
<span class="lno">6905 </span>    reg_mmatch = NULL;
<span class="lno">6906 </span>    reg_maxline = 0;
</span><span class="nop"><span class="lno"> </span>
</span><span class="nop"><span class="lno">6907 </span>    return vim_regsub_both(source, dest, copy, magic, backslash);
<span class="lno">6908 </span>}
<span class="lno">6909 </span>#endif
</span></td><td class="ttd"><span class="lin">Line 7380 to 7386</span><span class="nop"><span class="lno">7380 </span>    reg_match = rmp;
<span class="lno">7381 </span>    reg_mmatch = NULL;
<span class="lno">7382 </span>    reg_maxline = 0;
</span><span class="add"><span class="lno">7383 </span>    reg_buf = curbuf;
</span><span class="nop"><span class="lno">7384 </span>    return vim_regsub_both(source, dest, copy, magic, backslash);
<span class="lno">7385 </span>}
<span class="lno">7386 </span>#endif
</span></td></tr>
<tr><td class="ttd"><span class="lin">Line 6940 to 6946</span><span class="nop"><span class="lno">6940 </span>    int		c;
<span class="lno">6941 </span>    int		cc;
<span class="lno">6942 </span>    int		no = -1;
</span><span class="upd"><span class="lno">6943 </span>    fptr_T	func = (fptr_T)NULL;
</span><span class="nop"><span class="lno"> </span>
</span><span class="nop"><span class="lno">6944 </span>    linenr_T	clnum = 0;	/* init for GCC */
<span class="lno">6945 </span>    int		len = 0;	/* init for GCC */
<span class="lno">6946 </span>#ifdef FEAT_EVAL
</span></td><td class="ttd"><span class="lin">Line 7417 to 7424</span><span class="nop"><span class="lno">7417 </span>    int		c;
<span class="lno">7418 </span>    int		cc;
<span class="lno">7419 </span>    int		no = -1;
</span><span class="upd"><span class="lno">7420 </span>    fptr_T	func<span class="chg">_all</span> = (fptr_T)NULL;
</span><span class="add"><span class="lno">7421 </span>    fptr_T	func_one = (fptr_T)NULL;
</span><span class="nop"><span class="lno">7422 </span>    linenr_T	clnum = 0;	/* init for GCC */
<span class="lno">7423 </span>    int		len = 0;	/* init for GCC */
<span class="lno">7424 </span>#ifdef FEAT_EVAL
</span></td></tr>
<tr><td class="ttd"><span class="lin">Line 6997 to 7002</span><span class="nop"><span class="lno">6997 </span>	    submatch_mmatch = reg_mmatch;
<span class="lno">6998 </span>	    submatch_firstlnum = reg_firstlnum;
<span class="lno">6999 </span>	    submatch_maxline = reg_maxline;
</span><span class="nop"><span class="lno"> </span>
</span><span class="nop"><span class="lno">7000 </span>	    save_reg_win = reg_win;
<span class="lno">7001 </span>	    save_ireg_ic = ireg_ic;
<span class="lno">7002 </span>	    can_f_submatch = TRUE;
</span></td><td class="ttd"><span class="lin">Line 7475 to 7481</span><span class="nop"><span class="lno">7475 </span>	    submatch_mmatch = reg_mmatch;
<span class="lno">7476 </span>	    submatch_firstlnum = reg_firstlnum;
<span class="lno">7477 </span>	    submatch_maxline = reg_maxline;
</span><span class="add"><span class="lno">7478 </span>	    submatch_line_lbr = reg_line_lbr;
</span><span class="nop"><span class="lno">7479 </span>	    save_reg_win = reg_win;
<span class="lno">7480 </span>	    save_ireg_ic = ireg_ic;
<span class="lno">7481 </span>	    can_f_submatch = TRUE;
</span></td></tr>
<tr><td class="ttd"><span class="lin">Line 7008 to 7016</span><span class="nop"><span class="lno">7008 </span>
<span class="lno">7009 </span>		for (s = eval_result; *s != NUL; mb_ptr_adv(s))
<span class="lno">7010 </span>		{
</span><span class="upd"><span class="lno">7011 </span>		    /* Change NL to CR, so that it becomes a line break<span class="chg">.</span>
</span><span class="nop"><span class="lno"> </span>
</span><span class="nop"><span class="lno">7012 </span>		     * Skip over a backslashed character. */
</span><span class="upd"><span class="lno">7013 </span>		    if (*s == NL)
</span><span class="nop"><span class="lno">7014 </span>			*s = CAR;
<span class="lno">7015 </span>		    else if (*s == &#39;\\&#39; &amp;&amp; s[1] != NUL)
<span class="lno">7016 </span>		    {
</span></td><td class="ttd"><span class="lin">Line 7487 to 7496</span><span class="nop"><span class="lno">7487 </span>
<span class="lno">7488 </span>		for (s = eval_result; *s != NUL; mb_ptr_adv(s))
<span class="lno">7489 </span>		{
</span><span class="upd"><span class="lno">7490 </span>		    /* Change NL to CR, so that it becomes a line break<span class="chg">,</span>
</span><span class="add"><span class="lno">7491 </span>		     * unless called from vim_regexec_nl().
</span><span class="nop"><span class="lno">7492 </span>		     * Skip over a backslashed character. */
</span><span class="upd"><span class="lno">7493 </span>		    if (*s == NL<span class="chg"> &amp;&amp; !submatch_line_lbr</span>)
</span><span class="nop"><span class="lno">7494 </span>			*s = CAR;
<span class="lno">7495 </span>		    else if (*s == &#39;\\&#39; &amp;&amp; s[1] != NUL)
<span class="lno">7496 </span>		    {
</span></td></tr>
<tr><td class="ttd"><span class="lin">Line 7019 to 7026</span><span class="nop"><span class="lno">7019 </span>			 * :s/abc\\\ndef/\=&#34;aaa\\\nbbb&#34;/  on text:
<span class="lno">7020 </span>			 *   abc\
<span class="lno">7021 </span>			 *   def
</span><span class="nop"><span class="lno"> </span>
</span><span class="nop"><span class="lno">7022 </span>			 */
</span><span class="upd"><span class="lno">7023 </span>			if (*s == NL)
</span><span class="nop"><span class="lno">7024 </span>			    *s = CAR;
<span class="lno">7025 </span>			had_backslash = TRUE;
<span class="lno">7026 </span>		    }
</span></td><td class="ttd"><span class="lin">Line 7499 to 7507</span><span class="nop"><span class="lno">7499 </span>			 * :s/abc\\\ndef/\=&#34;aaa\\\nbbb&#34;/  on text:
<span class="lno">7500 </span>			 *   abc\
<span class="lno">7501 </span>			 *   def
</span><span class="add"><span class="lno">7502 </span>			 * Not when called from vim_regexec_nl().
</span><span class="nop"><span class="lno">7503 </span>			 */
</span><span class="upd"><span class="lno">7504 </span>			if (*s == NL<span class="chg"> &amp;&amp; !submatch_line_lbr</span>)
</span><span class="nop"><span class="lno">7505 </span>			    *s = CAR;
<span class="lno">7506 </span>			had_backslash = TRUE;
<span class="lno">7507 </span>		    }
</span></td></tr>
<tr><td class="ttd"><span class="lin">Line 7043 to 7048</span><span class="nop"><span class="lno">7043 </span>	    reg_mmatch = submatch_mmatch;
<span class="lno">7044 </span>	    reg_firstlnum = submatch_firstlnum;
<span class="lno">7045 </span>	    reg_maxline = submatch_maxline;
</span><span class="nop"><span class="lno"> </span>
</span><span class="nop"><span class="lno">7046 </span>	    reg_win = save_reg_win;
<span class="lno">7047 </span>	    ireg_ic = save_ireg_ic;
<span class="lno">7048 </span>	    can_f_submatch = FALSE;
</span></td><td class="ttd"><span class="lin">Line 7524 to 7530</span><span class="nop"><span class="lno">7524 </span>	    reg_mmatch = submatch_mmatch;
<span class="lno">7525 </span>	    reg_firstlnum = submatch_firstlnum;
<span class="lno">7526 </span>	    reg_maxline = submatch_maxline;
</span><span class="add"><span class="lno">7527 </span>	    reg_line_lbr = submatch_line_lbr;
</span><span class="nop"><span class="lno">7528 </span>	    reg_win = save_reg_win;
<span class="lno">7529 </span>	    ireg_ic = save_ireg_ic;
<span class="lno">7530 </span>	    can_f_submatch = FALSE;
</span></td></tr>
<tr><td class="ttd"><span class="lin">Line 7069 to 7084</span><span class="nop"><span class="lno">7069 </span>	    {
<span class="lno">7070 </span>		switch (*src++)
<span class="lno">7071 </span>		{
</span><span class="upd"><span class="lno">7072 </span>		case &#39;u&#39;:   func = (fptr_T)do_upper;
</span><span class="nop"><span class="lno">7073 </span>			    continue;
</span><span class="upd"><span class="lno">7074 </span>		case &#39;U&#39;:   func = (fptr_T)do_Upper;
</span><span class="nop"><span class="lno">7075 </span>			    continue;
</span><span class="upd"><span class="lno">7076 </span>		case &#39;l&#39;:   func = (fptr_T)do_lower;
</span><span class="nop"><span class="lno">7077 </span>			    continue;
</span><span class="upd"><span class="lno">7078 </span>		case &#39;L&#39;:   func = (fptr_T)do_Lower;
</span><span class="nop"><span class="lno">7079 </span>			    continue;
<span class="lno">7080 </span>		case &#39;e&#39;:
</span><span class="upd"><span class="lno">7081 </span>		case &#39;E&#39;:   func = (fptr_T)NULL;
</span><span class="nop"><span class="lno">7082 </span>			    continue;
<span class="lno">7083 </span>		}
<span class="lno">7084 </span>	    }
</span></td><td class="ttd"><span class="lin">Line 7551 to 7566</span><span class="nop"><span class="lno">7551 </span>	    {
<span class="lno">7552 </span>		switch (*src++)
<span class="lno">7553 </span>		{
</span><span class="upd"><span class="lno">7554 </span>		case &#39;u&#39;:   func<span class="chg">_one</span> = (fptr_T)do_upper;
</span><span class="nop"><span class="lno">7555 </span>			    continue;
</span><span class="upd"><span class="lno">7556 </span>		case &#39;U&#39;:   func<span class="chg">_all</span> = (fptr_T)do_Upper;
</span><span class="nop"><span class="lno">7557 </span>			    continue;
</span><span class="upd"><span class="lno">7558 </span>		case &#39;l&#39;:   func<span class="chg">_one</span> = (fptr_T)do_lower;
</span><span class="nop"><span class="lno">7559 </span>			    continue;
</span><span class="upd"><span class="lno">7560 </span>		case &#39;L&#39;:   func<span class="chg">_all</span> = (fptr_T)do_Lower;
</span><span class="nop"><span class="lno">7561 </span>			    continue;
<span class="lno">7562 </span>		case &#39;e&#39;:
</span><span class="upd"><span class="lno">7563 </span>		case &#39;E&#39;:   func<span class="chg">_one = func_all</span> = (fptr_T)NULL;
</span><span class="nop"><span class="lno">7564 </span>			    continue;
<span class="lno">7565 </span>		}
<span class="lno">7566 </span>	    }
</span></td></tr>
<tr><td class="ttd"><span class="lin">Line 7131 to 7141</span><span class="nop"><span class="lno">7131 </span>#endif
<span class="lno">7132 </span>
<span class="lno">7133 </span>	    /* Write to buffer, if copy is set. */
</span><span class="upd"><span class="lno">7134 </span>	    if (func <span class="chg">=</span>= (fptr_T)NULL)<span class="chg">	/* just copy */</span>
</span><span class="nop"><span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
</span><span class="nop"><span class="lno">7135 </span>		cc = c;
</span><span class="del"><span class="lno">7136 </span>	    else
<span class="lno">7137 </span>		/* Turbo C complains without the typecast */
<span class="lno">7138 </span>		func = (fptr_T)(func(&amp;cc, c));
</span><span class="nop"><span class="lno">7139 </span>
<span class="lno">7140 </span>#ifdef FEAT_MBYTE
<span class="lno">7141 </span>	    if (has_mbyte)
</span></td><td class="ttd"><span class="lin">Line 7613 to 7626</span><span class="nop"><span class="lno">7613 </span>#endif
<span class="lno">7614 </span>
<span class="lno">7615 </span>	    /* Write to buffer, if copy is set. */
</span><span class="upd"><span class="lno">7616 </span>	    if (func<span class="chg">_one</span> <span class="chg">!</span>= (fptr_T)NULL)
</span><span class="add"><span class="lno">7617 </span>		/* Turbo C complains without the typecast */
<span class="lno">7618 </span>		func_one = (fptr_T)(func_one(&amp;cc, c));
<span class="lno">7619 </span>	    else if (func_all != (fptr_T)NULL)
<span class="lno">7620 </span>		/* Turbo C complains without the typecast */
<span class="lno">7621 </span>		func_all = (fptr_T)(func_all(&amp;cc, c));
<span class="lno">7622 </span>	    else /* just copy */
</span><span class="nop"><span class="lno">7623 </span>		cc = c;
</span><span class="nop"><span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
</span><span class="nop"><span class="lno">7624 </span>
<span class="lno">7625 </span>#ifdef FEAT_MBYTE
<span class="lno">7626 </span>	    if (has_mbyte)
</span></td></tr>
<tr><td class="ttd"><span class="lin">Line 7246 to 7256</span><span class="nop"><span class="lno">7246 </span>#endif
<span class="lno">7247 </span>				c = *s;
<span class="lno">7248 </span>
</span><span class="upd"><span class="lno">7249 </span>			    if (func <span class="chg">=</span>= (fptr_T)NULL)<span class="chg">	/* just copy */</span>
</span><span class="nop"><span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
</span><span class="nop"><span class="lno">7250 </span>				cc = c;
</span><span class="del"><span class="lno">7251 </span>			    else
<span class="lno">7252 </span>				/* Turbo C complains without the typecast */
<span class="lno">7253 </span>				func = (fptr_T)(func(&amp;cc, c));
</span><span class="nop"><span class="lno">7254 </span>
<span class="lno">7255 </span>#ifdef FEAT_MBYTE
<span class="lno">7256 </span>			    if (has_mbyte)
</span></td><td class="ttd"><span class="lin">Line 7731 to 7744</span><span class="nop"><span class="lno">7731 </span>#endif
<span class="lno">7732 </span>				c = *s;
<span class="lno">7733 </span>
</span><span class="upd"><span class="lno">7734 </span>			    if (func<span class="chg">_one</span> <span class="chg">!</span>= (fptr_T)NULL)
</span><span class="add"><span class="lno">7735 </span>				/* Turbo C complains without the typecast */
<span class="lno">7736 </span>				func_one = (fptr_T)(func_one(&amp;cc, c));
<span class="lno">7737 </span>			    else if (func_all != (fptr_T)NULL)
<span class="lno">7738 </span>				/* Turbo C complains without the typecast */
<span class="lno">7739 </span>				func_all = (fptr_T)(func_all(&amp;cc, c));
<span class="lno">7740 </span>			    else /* just copy */
</span><span class="nop"><span class="lno">7741 </span>				cc = c;
</span><span class="nop"><span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
</span><span class="nop"><span class="lno">7742 </span>
<span class="lno">7743 </span>#ifdef FEAT_MBYTE
<span class="lno">7744 </span>			    if (has_mbyte)
</span></td></tr>
<tr><td class="ttd"><span class="lin">Line 7411 to 7413</span><span class="nop"><span class="lno">7411 </span>    return retval;
<span class="lno">7412 </span>}
<span class="lno">7413 </span>#endif
</span><span class="nop"><span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
<span class="lno"> </span>
</span></td><td class="ttd"><span class="lin">Line 7899 to 8090</span><span class="nop"><span class="lno">7899 </span>    return retval;
<span class="lno">7900 </span>}
<span class="lno">7901 </span>#endif
</span><span class="add"><span class="lno">7902 </span>
<span class="lno">7903 </span>static regengine_T bt_regengine =
<span class="lno">7904 </span>{
<span class="lno">7905 </span>    bt_regcomp,
<span class="lno">7906 </span>    bt_regfree,
<span class="lno">7907 </span>    bt_regexec,
<span class="lno">7908 </span>#if defined(FEAT_MODIFY_FNAME) || defined(FEAT_EVAL) \
<span class="lno">7909 </span>	|| defined(FIND_REPLACE_DIALOG) || defined(PROTO)
<span class="lno">7910 </span>    bt_regexec_nl,
<span class="lno">7911 </span>#endif
<span class="lno">7912 </span>    bt_regexec_multi
<span class="lno">7913 </span>#ifdef DEBUG
<span class="lno">7914 </span>    ,(char_u *)&#34;&#34;
<span class="lno">7915 </span>#endif
<span class="lno">7916 </span>};
<span class="lno">7917 </span>
<span class="lno">7918 </span>
<span class="lno">7919 </span>#include &#34;regexp_nfa.c&#34;
<span class="lno">7920 </span>
<span class="lno">7921 </span>static regengine_T nfa_regengine =
<span class="lno">7922 </span>{
<span class="lno">7923 </span>    nfa_regcomp,
<span class="lno">7924 </span>    nfa_regfree,
<span class="lno">7925 </span>    nfa_regexec,
<span class="lno">7926 </span>#if defined(FEAT_MODIFY_FNAME) || defined(FEAT_EVAL) \
<span class="lno">7927 </span>	|| defined(FIND_REPLACE_DIALOG) || defined(PROTO)
<span class="lno">7928 </span>    nfa_regexec_nl,
<span class="lno">7929 </span>#endif
<span class="lno">7930 </span>    nfa_regexec_multi
<span class="lno">7931 </span>#ifdef DEBUG
<span class="lno">7932 </span>    ,(char_u *)&#34;&#34;
<span class="lno">7933 </span>#endif
<span class="lno">7934 </span>};
<span class="lno">7935 </span>
<span class="lno">7936 </span>/* Which regexp engine to use? Needed for vim_regcomp().
<span class="lno">7937 </span> * Must match with &#39;regexpengine&#39;. */
<span class="lno">7938 </span>static int regexp_engine = 0;
<span class="lno">7939 </span>#define	    AUTOMATIC_ENGINE	0
<span class="lno">7940 </span>#define	    BACKTRACKING_ENGINE	1
<span class="lno">7941 </span>#define	    NFA_ENGINE		2
<span class="lno">7942 </span>#ifdef DEBUG
<span class="lno">7943 </span>static char_u regname[][30] = {
<span class="lno">7944 </span>		    &#34;AUTOMATIC Regexp Engine&#34;,
<span class="lno">7945 </span>		    &#34;BACKTRACKING Regexp Engine&#34;,
<span class="lno">7946 </span>		    &#34;NFA Regexp Engine&#34;
<span class="lno">7947 </span>			    };
<span class="lno">7948 </span>#endif
<span class="lno">7949 </span>
<span class="lno">7950 </span>/*
<span class="lno">7951 </span> * Compile a regular expression into internal code.
<span class="lno">7952 </span> * Returns the program in allocated memory.
<span class="lno">7953 </span> * Use vim_regfree() to free the memory.
<span class="lno">7954 </span> * Returns NULL for an error.
<span class="lno">7955 </span> */
<span class="lno">7956 </span>    regprog_T *
<span class="lno">7957 </span>vim_regcomp(expr_arg, re_flags)
<span class="lno">7958 </span>    char_u	*expr_arg;
<span class="lno">7959 </span>    int		re_flags;
<span class="lno">7960 </span>{
<span class="lno">7961 </span>    regprog_T   *prog = NULL;
<span class="lno">7962 </span>    char_u	*expr = expr_arg;
<span class="lno">7963 </span>
<span class="lno">7964 </span>    regexp_engine = p_re;
<span class="lno">7965 </span>
<span class="lno">7966 </span>    /* Check for prefix &#34;\%#=&#34;, that sets the regexp engine */
<span class="lno">7967 </span>    if (STRNCMP(expr, &#34;\\%#=&#34;, 4) == 0)
<span class="lno">7968 </span>    {
<span class="lno">7969 </span>	int newengine = expr[4] - &#39;0&#39;;
<span class="lno">7970 </span>
<span class="lno">7971 </span>	if (newengine == AUTOMATIC_ENGINE
<span class="lno">7972 </span>	    || newengine == BACKTRACKING_ENGINE
<span class="lno">7973 </span>	    || newengine == NFA_ENGINE)
<span class="lno">7974 </span>	{
<span class="lno">7975 </span>	    regexp_engine = expr[4] - &#39;0&#39;;
<span class="lno">7976 </span>	    expr += 5;
<span class="lno">7977 </span>#ifdef DEBUG
<span class="lno">7978 </span>	    EMSG3(&#34;New regexp mode selected (%d): %s&#34;, regexp_engine,
<span class="lno">7979 </span>						    regname[newengine]);
<span class="lno">7980 </span>#endif
<span class="lno">7981 </span>	}
<span class="lno">7982 </span>	else
<span class="lno">7983 </span>	{
<span class="lno">7984 </span>	    EMSG(_(&#34;E864: \\%#= can only be followed by 0, 1, or 2. The automatic engine will be used &#34;));
<span class="lno">7985 </span>	    regexp_engine = AUTOMATIC_ENGINE;
<span class="lno">7986 </span>	}
<span class="lno">7987 </span>    }
<span class="lno">7988 </span>#ifdef DEBUG
<span class="lno">7989 </span>    bt_regengine.expr = expr;
<span class="lno">7990 </span>    nfa_regengine.expr = expr;
<span class="lno">7991 </span>#endif
<span class="lno">7992 </span>
<span class="lno">7993 </span>    /*
<span class="lno">7994 </span>     * First try the NFA engine, unless backtracking was requested.
<span class="lno">7995 </span>     */
<span class="lno">7996 </span>    if (regexp_engine != BACKTRACKING_ENGINE)
<span class="lno">7997 </span>        prog = nfa_regengine.regcomp(expr, re_flags);
<span class="lno">7998 </span>    else
<span class="lno">7999 </span>	prog = bt_regengine.regcomp(expr, re_flags);
<span class="lno">8000 </span>
<span class="lno">8001 </span>    if (prog == NULL)	    /* error compiling regexp with initial engine */
<span class="lno">8002 </span>    {
<span class="lno">8003 </span>#ifdef BT_REGEXP_DEBUG_LOG
<span class="lno">8004 </span>	if (regexp_engine != BACKTRACKING_ENGINE)   /* debugging log for NFA */
<span class="lno">8005 </span>	{
<span class="lno">8006 </span>	    FILE *f;
<span class="lno">8007 </span>	    f = fopen(BT_REGEXP_DEBUG_LOG_NAME, &#34;a&#34;);
<span class="lno">8008 </span>	    if (f)
<span class="lno">8009 </span>	    {
<span class="lno">8010 </span>		fprintf(f, &#34;Syntax error in \&#34;%s\&#34;\n&#34;, expr);
<span class="lno">8011 </span>		fclose(f);
<span class="lno">8012 </span>	    }
<span class="lno">8013 </span>	    else
<span class="lno">8014 </span>		EMSG2(&#34;(NFA) Could not open \&#34;%s\&#34; to write !!!&#34;,
<span class="lno">8015 </span>                        BT_REGEXP_DEBUG_LOG_NAME);
<span class="lno">8016 </span>	}
<span class="lno">8017 </span>#endif
<span class="lno">8018 </span>	/*
<span class="lno">8019 </span>	 * If NFA engine failed, then revert to the backtracking engine.
<span class="lno">8020 </span>	 * Except when there was a syntax error, which was properly handled by
<span class="lno">8021 </span>	 * NFA engine.
<span class="lno">8022 </span>	 */
<span class="lno">8023 </span>	if (regexp_engine == AUTOMATIC_ENGINE)
<span class="lno">8024 </span>	    prog = bt_regengine.regcomp(expr, re_flags);
<span class="lno">8025 </span>    }
<span class="lno">8026 </span>
<span class="lno">8027 </span>    return prog;
<span class="lno">8028 </span>}
<span class="lno">8029 </span>
<span class="lno">8030 </span>/*
<span class="lno">8031 </span> * Free a compiled regexp program, returned by vim_regcomp().
<span class="lno">8032 </span> */
<span class="lno">8033 </span>    void
<span class="lno">8034 </span>vim_regfree(prog)
<span class="lno">8035 </span>    regprog_T   *prog;
<span class="lno">8036 </span>{
<span class="lno">8037 </span>    if (prog != NULL)
<span class="lno">8038 </span>	prog-&gt;engine-&gt;regfree(prog);
<span class="lno">8039 </span>}
<span class="lno">8040 </span>
<span class="lno">8041 </span>/*
<span class="lno">8042 </span> * Match a regexp against a string.
<span class="lno">8043 </span> * &#34;rmp-&gt;regprog&#34; is a compiled regexp as returned by vim_regcomp().
<span class="lno">8044 </span> * Uses curbuf for line count and &#39;iskeyword&#39;.
<span class="lno">8045 </span> *
<span class="lno">8046 </span> * Return TRUE if there is a match, FALSE if not.
<span class="lno">8047 </span> */
<span class="lno">8048 </span>    int
<span class="lno">8049 </span>vim_regexec(rmp, line, col)
<span class="lno">8050 </span>    regmatch_T *rmp;
<span class="lno">8051 </span>    char_u      *line;  /* string to match against */
<span class="lno">8052 </span>    colnr_T     col;    /* column to start looking for match */
<span class="lno">8053 </span>{
<span class="lno">8054 </span>    return rmp-&gt;regprog-&gt;engine-&gt;regexec(rmp, line, col);
<span class="lno">8055 </span>}
<span class="lno">8056 </span>
<span class="lno">8057 </span>#if defined(FEAT_MODIFY_FNAME) || defined(FEAT_EVAL) \
<span class="lno">8058 </span>	|| defined(FIND_REPLACE_DIALOG) || defined(PROTO)
<span class="lno">8059 </span>/*
<span class="lno">8060 </span> * Like vim_regexec(), but consider a &#34;\n&#34; in &#34;line&#34; to be a line break.
<span class="lno">8061 </span> */
<span class="lno">8062 </span>    int
<span class="lno">8063 </span>vim_regexec_nl(rmp, line, col)
<span class="lno">8064 </span>    regmatch_T *rmp;
<span class="lno">8065 </span>    char_u *line;
<span class="lno">8066 </span>    colnr_T col;
<span class="lno">8067 </span>{
<span class="lno">8068 </span>    return rmp-&gt;regprog-&gt;engine-&gt;regexec_nl(rmp, line, col);
<span class="lno">8069 </span>}
<span class="lno">8070 </span>#endif
<span class="lno">8071 </span>
<span class="lno">8072 </span>/*
<span class="lno">8073 </span> * Match a regexp against multiple lines.
<span class="lno">8074 </span> * &#34;rmp-&gt;regprog&#34; is a compiled regexp as returned by vim_regcomp().
<span class="lno">8075 </span> * Uses curbuf for line count and &#39;iskeyword&#39;.
<span class="lno">8076 </span> *
<span class="lno">8077 </span> * Return zero if there is no match.  Return number of lines contained in the
<span class="lno">8078 </span> * match otherwise.
<span class="lno">8079 </span> */
<span class="lno">8080 </span>    long
<span class="lno">8081 </span>vim_regexec_multi(rmp, win, buf, lnum, col, tm)
<span class="lno">8082 </span>    regmmatch_T *rmp;
<span class="lno">8083 </span>    win_T       *win;           /* window in which to search or NULL */
<span class="lno">8084 </span>    buf_T       *buf;           /* buffer in which to search */
<span class="lno">8085 </span>    linenr_T    lnum;           /* nr of line to start looking for match */
<span class="lno">8086 </span>    colnr_T     col;            /* column to start looking for match */
<span class="lno">8087 </span>    proftime_T	*tm;		/* timeout limit or NULL */
<span class="lno">8088 </span>{
<span class="lno">8089 </span>    return rmp-&gt;regprog-&gt;engine-&gt;regexec_multi(rmp, win, buf, lnum, col, tm);
<span class="lno">8090 </span>}
</span></td></tr>
</table><br>
Generated on Tue, 29 Apr 2014 16:58:40 EST<br><br><b>Legend:</b><br><table class="tab">
<tr><td class="tth"><span class="hdr">filename 1</span></td><td class="tth"><span class="hdr">filename 2</span></td></tr>
<tr><td class="ttd">
<span class="lin">Line 1 to 3</span>
<span class="del"><span class="lno">1 </span>line deleted</span>
<span class="nop"><span class="lno">2 </span>no change</span>
<span class="upd"><span class="lno">3 </span>line modified</span>
</td>
<td class="ttd">
<span class="lin">Line 1 to 3</span>
<span class="add"><span class="lno">1 </span>line added</span>
<span class="nop"><span class="lno">2 </span>no change</span>
<span class="upd"><span class="lno">3 </span><span class="chg">L</span>ine <span class="chg">M</span>odified</span>
</td></tr>
</table>
</body></html>
